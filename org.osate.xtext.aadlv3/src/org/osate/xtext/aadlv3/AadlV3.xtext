// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	'package' name=QualifiedName 
	imports+=Import*
	elements+=(PackageDeclaration | PrimitiveType | ComponentInterface | ComponentImplementation | ComponentConfiguration | Property | PropertySet | Workingset)*
	'end' QualifiedName? SEMICOLON;


Property returns av3::Property:
	'property' name=ID type=[av3::Type|QualifiedName] SEMICOLON;

PropertySet returns av3::PropertySet:
	name=ID ':' 'properties' 'is' 
		properties += [av3::Property|QualifiedName] (',' properties += [av3::Property|QualifiedName])*
		'end' ID? SEMICOLON
;

PrimitiveType returns av3::PrimitiveType:
	'type' name=ID SEMICOLON;

ComponentInterface returns av3::ComponentInterface:
	category=ComponentCategory? 'interface'  name=ID ('extends' (InterfaceExtensions)?)? 
	('use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* )?
	(SectionsInterfaceBody | InterfaceBody)
	'end' ID? SEMICOLON;
	
fragment SectionsInterfaceBody*:
	('features' features+=Feature+)?
	('flows' (flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink)+)?
 	('properties' PropertyElement+ )?
;

fragment InterfaceBody*:
	'is' (features+=Feature | flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink | PropertyElement)*
;

ComponentImplementation returns av3::ComponentImplementation:
	category=ComponentCategory interface =[av3::ComponentInterface|QualifiedName] '.'name=ID 
	('extends' (ClassifierExtensions)?)? 
	(SectionsImplementationBody | ImplementationBody )
	'end' DottedName? SEMICOLON;

fragment SectionsImplementationBody*:
	('subcomponents'(components+=Component|assignments+=ConfigurationAssignment)+ )?
 	('connections' connections+=(Connection|FeatureMapping)+ )?
 	('flows' (flowAssignments+=FlowAssignment| paths+= Path )+)?
 	('properties' PropertyElement+ )?
;

fragment ImplementationBody*:
	'is' (connections+=Connection |connections+=FeatureMapping | components+=Component | paths+= Path | flowAssignments+=FlowAssignment | assignments+=ConfigurationAssignment| PropertyElement)*
;

ComponentConfiguration returns av3::ComponentConfiguration:
	'configuration' interface =[av3::ComponentInterface|QualifiedName]'.'name=ID  
	Parameters?
	'extends' ClassifierExtensions ConfigurationElementBlock? 
	'end' DottedName? SEMICOLON;
	

// (Instance) model elements

Feature returns av3::Feature:
	name=ID ':' direction=FeatureDirection? sampled?='sampled'? category=FeatureCategory 
	reverse?='reverse'? type=[av3::Type|QualifiedName]? PropertiesBlock?
	SEMICOLON;

Component returns av3::Component:
	name=ID ':' category=ComponentCategory
	typeReference=TypeReference? NestedComponentImplementationBlock?
 SEMICOLON;

Connection returns av3::Association:
	name=ID ':' associationType=ConnectionType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? SEMICOLON;

FeatureMapping returns av3::Association:
	name=ID ':' associationType=MappingType source=ModelElementReference
	'=>' destination=ModelElementReference PropertiesBlock? SEMICOLON;


FlowPath returns av3::Association:
	name=ID ':' associationType=FlowPathType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? SEMICOLON;

FlowSource returns av3::Association:
	name=ID ':' associationType=FlowSourceType destination=ModelElementReference PropertiesBlock? SEMICOLON;

FlowSink returns av3::Association:
	name=ID ':' associationType=FlowSinkType source=ModelElementReference
	 PropertiesBlock? SEMICOLON;


Path returns av3::PathSequence:
	name=ID ':' EndToEndFlowKeywords elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? SEMICOLON;


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' importedNamespace=QualifiedNameWithWildcard SEMICOLON;

ConfigurationAssignment returns av3::ConfigurationAssignment:
	target= ModelElementReference '=>' 
	((value=TypeReference (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	SEMICOLON;


FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	SEMICOLON;


PropertyAssociation returns av3::PropertyAssociation:
	target=PropertyReference  '=>' 
	value=PropertyValue SEMICOLON;

PropertyValue returns av3::PropertyValue:
	 value=INT
;

ModelElementReference returns av3::ModelElementReference:
	element=[av3::ModelElement|ID] => ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


PropertyReference returns av3::ModelElementReference: 
	(element=[av3::ModelElement|ID] => ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*)? '#' property=[av3::Property|QualifiedName] 
		;

fragment ConfigurationElementBlock *:
	'is' ( propertyAssociations+=PropertyAssociation | assignments+=ConfigurationAssignment )+;

fragment CurlyConfigurationElementBlock *:
	'{' (PropertyElement | ConfigurationElement )* '}';

fragment PropertyElement*:
     propertyAssociations+=PropertyAssociation	
;

fragment ConfigurationElement *:
	assignments+=ConfigurationAssignment;

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName] ;


// reference objects for classifiers including configurations with parameter

ReversableTypeReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::Type|QualifiedName] ConfigurationActuals? ;

TypeReference returns av3::TypeReference :  
	(( componentinterface=[av3::ComponentInterface|QualifiedName] '.' type=[av3::Type|ID])
		| type=[av3::Type|QualifiedName]
	)  ConfigurationActuals?
;

fragment PropertiesBlock *:
	'{' PropertyElement* '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{' (features+=Feature | connections+=Connection| connections+=FeatureMapping  | components+=Component |  PropertyElement)* '}';



fragment ClassifierExtensions *:
	superClassifiers +=TypeReference
	("," superClassifiers +=TypeReference)*;


fragment InterfaceExtensions *:
	superClassifiers +=ReversableTypeReference
	("," superClassifiers +=ReversableTypeReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' value=TypeReference
;

Workingset returns av3::Workingset: 
	'workingset' name=QualifiedName 'is' rootComponents+=Component* 'end' SEMICOLON?
;



QualifiedNameWithWildcard:
	QualifiedName '::*'?;

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('::' ID)*;

SEMICOLON:
	';';


ComponentCategory returns av3::ComponentCategory: 'component' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | 'access' 
	|BusAccessKeywords | 'binding' | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;


ConnectionType returns av3::AssociationType:
	'feature'| 'bus' | 'binding' | 'interface'| 'port'| 'data' ;

MappingType returns av3::AssociationType:
	'mapping' ;

FlowPathType returns av3::AssociationType:
	FlowPathKeywords ;

FlowSourceType returns av3::AssociationType:
	FlowSourceKeywords ;

FlowSinkType returns av3::AssociationType:
	FlowSinkKeywords ;


VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

EndToEndFlowKeywords: 'end''to''end''flow';
FlowSourceKeywords: 'flow''source';
FlowSinkKeywords: 'flow''sink';
FlowPathKeywords: 'flow''path';

InOutKeywords: 'in' 'out'; 
BusAccessKeywords: 'bus''access' ; 

ProvidesReadKeywords: 'provides' 'read';
RequiresReadKeywords: 'requires' 'read';
ProvidesWriteKeywords: 'provides' 'write';
RequiresWriteKeywords: 'requires' 'write';
ProvidesRWKeywords: 'provides' 'readwrite';
RequiresRWKeywords: 'requires' 'readwrite';
        
