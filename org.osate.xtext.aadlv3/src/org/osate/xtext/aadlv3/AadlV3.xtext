// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	 (annotations+=Annotation )*
	(private?='private')? 'package' name=QualifiedName 'is'
	
	( elements+=AnnexLibrary |
	(imports+=Import |
	elements+= PackageElement)*
	)
	'end' ';';

AnnexLibrary returns av3::AnnexLibrary :
	'@' name=ID '{' '}'
;

PackageElement returns av3::PackageElement:
	 (PackageDeclaration  | ComponentInterface | ComponentImplementation | ComponentConfiguration | PropertyDefinition | PropertySet | Workingset
	| TypeDef  )
	;

PropertyDefinition returns av3::PropertyDefinition:
	 (annotations+=Annotation )*
	(private?='private')? 'property' name=ID ':' type=Type
	('for' '(' ( forAll?='all' | (AppliesTo (',' AppliesTo)*)) ')'  )? 
	';' ;

fragment AppliesTo*:
	componentCategories+=ComponentCategory | featureCategories+=FeatureCategory 
		| associationTypes+=AssociationType 
	
;

PropertySet returns av3::PropertySet:
	 (annotations+=Annotation )*
	(private?='private')? 'properties' name=ID  ':'
		'{' properties += [av3::PropertyDefinition|QualifiedReference] (',' properties += [av3::PropertyDefinition|QualifiedName])* '}'
	';'
;

TypeDef returns av3::TypeDef:
	 (annotations+=Annotation )*
	(private?='private')? 'type' name=ID ('extends' superType=Type)?
	(':' baseType=Type)?
		PropertiesBlock? ';'
;



PropertyAssociation returns av3::PropertyAssociation:
	 ( target=ModelElementReference)? 
	 '#' property=[av3::PropertyDefinition|QualifiedName] 
	propertyAssociationType=PropertyAssociationType value=Literal
	 ';'
	;

PropertyAssociationType returns av3::PropertyAssociationType:
	'=>' | '=' | '*=>' 
;

ModelElementReference returns av3::NamedElementReference:
	// => or -> both work
	element=[av3::ModelElement|ID] -> ({av3::NamedElementReference.context=current} '.' element=[av3::ModelElement|ID])*;

NamedElementReference returns av3::NamedElementReference:
	// => or -> both work
	element=[av3::NamedElement|QualifiedReference] -> ({av3::NamedElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


ComponentInterface returns av3::ComponentInterface:
	 (annotations+=Annotation )*
	(private?='private')? category=ComponentCategory? 'interface'  name=ID ('extends' InterfaceExtensions)? 
	 InterfaceBody ';'
	;

fragment InterfaceBody*:
	'is' (InterfaceElement )*  'end'
;
fragment InterfaceElement*:
	 elements+= (Feature| StateVariable | Transition | Behavior| Generator
	   |  BehaviorAnnotationBlock | AnnexSubclause) | ownedPropertyAssociations+=PropertyAssociation
;
	

ComponentImplementation returns av3::ComponentImplementation:
	 (annotations+=Annotation )*
	(private?='private')? category=ComponentCategory name=DottedName 
	('extends' ImplementationExtensions)? 
	 ImplementationBody ';'
	  ;

fragment ImplementationBody*:
	'is' (ImplementationElement )* 	'end'
;

fragment ImplementationElement* :
	elements+=(Connection |  Binding | Subcomponent | EndToEndFlow |  BehaviorAnnotationBlock
		| StateVariable | Transition | Behavior|  Generator | AnnexSubclause)
		| flowAssignments+=FlowAssignment | classifierAssignments+=ClassifierAssignment | classifierAssignments+=ClassifierAssignmentPattern
		| ownedPropertyAssociations+=PropertyAssociation 
;

ComponentConfiguration returns av3::ComponentConfiguration:
	 (annotations+=Annotation )*
	(private?='private')? 'configuration' name=DottedName  
	Parameters?
	// optional extension. If no extends then we have a generic configuration with patterns
	('extends' ConfigurationExtensions)? ConfigurationElementBlock ';'
	 ;
	

// (Instance) model elements

Feature returns av3::Feature:
	 (annotations+=Annotation )*
	name=ID ':' direction=FeatureDirection?  
	category=FeatureCategory 
	(typeReference=ReversableTypeReference )?
	PropertiesBlock? ';'
	;

Subcomponent returns av3::Subcomponent:
{av3::Subcomponent}	 (annotations+=Annotation )*
	name=ID ':' category=ComponentCategory
	( ( typeReferences+=ClassifierOrTypeReference InStates? PropertiesBlock?) 
	| ( InStates? NestedComponentImplementationBlock)
	) 
	 ';'
 ;

Connection returns av3::Association:
	name=ID ':' associationType=IsConnection source=ModelElementReference
	('->'|bidirectional?='<->') destination=ModelElementReference InStates? PropertiesBlock? ';';


Binding returns av3::Association:
	name=ID ':' bindingType=[av3::TypeDef|QualifiedName]? associationType=IsBinding 
	source=ModelElementReference
	'->' destination=ModelElementReference InStates? PropertiesBlock? ';';


fragment UseProps*:	
	'use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* 
	';'
;

fragment InStates*:	
	'when' inStates = (ModelElementContainsEnumerationLiteral| ModelElementEqualsEnumerationLiteral)
;

EndToEndFlow returns av3::PathSequence:
	name=ID ':' EndToEndFLowKeywords elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? ';';


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' (importedNamespace=QualifiedNameWithWildcard | importedNamespace=QualifiedName)
	('as' alias=ID)?
	';';

ClassifierAssignment returns av3::ClassifierAssignment:
	target= ModelElementReference '=>' 
	((assignedClassifiers+=ClassifierOrTypeReference (',' assignedClassifiers+=ClassifierOrTypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	';'
	;

ClassifierAssignmentPattern returns av3::ClassifierAssignmentPattern:
	QueryExpression '=>' 
	((assignedClassifiers+=ClassifierOrTypeReference (',' assignedClassifiers+=ClassifierOrTypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	';'
	;

fragment QueryExpression *: 
'all''('targetPattern = [av3::Type|QualifiedTypesReference] ')';

FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	';'
	;



fragment ConfigurationElementBlock *:
	'is' (ConfigurationElement )* 'end';

fragment CurlyConfigurationElementBlock *:
	'{' (ConfigurationElement  )+ '}'; 

fragment ConfigurationElement*: 
	ownedPropertyAssociations+=PropertyAssociation  | elements += BehaviorAnnotationBlock |
	elements+=Binding | classifierAssignments+=ClassifierAssignment | classifierAssignments+=ClassifierAssignmentPattern | elements+=AnnexSubclause
;

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName];


// reference objects for classifiers including configurations with parameter

ReversableInterfaceReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::ComponentInterface|QualifiedReference] ;

ReversableTypeReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::NamedType|QualifiedReference] ;

ClassifierOrTypeReference returns av3::TypeReference :  
	 type=[av3::NamedType|QualifiedTypesReference]
	  ConfigurationActuals?
;

TypeReference returns av3::TypeReference :  
	 type=[av3::NamedType|QualifiedName]
;

Type returns av3::Type :  
	 TypeReference | CompositeType | PrimitiveType | EnumerationType
;

EnumerationType returns av3::EnumerationType :
	{av3::EnumerationType} 'enum' '(' literals+=EnumerationLiteral* ')'
;

CompositeType returns av3::CompositeType:
	compositeType=Composite 'of' type=TypeReference
;

PrimitiveType returns av3::PrimitiveType:
	primitiveType=Primitive
;

RealizationReference returns av3::TypeReference :  
	 type=[av3::ComponentRealization|QualifiedDottedReference]
	  ConfigurationActuals?
;

ImplementationReference returns av3::TypeReference :  
	 type=[av3::ComponentImplementation|QualifiedDottedReference]
;

AnnexSubclause returns av3::AnnexSubclause :
	DefaultAnnexSubclause
;

DefaultAnnexSubclause returns av3::DefaultAnnexSubclause :
	'@' name=ID  body=ANNEXTEXT ';'
;


fragment PropertiesBlock *:
	'{' (ownedPropertyAssociations+=PropertyAssociation )+ '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{'  ( NestedImplementationElement )+ 
	 	'}';
	 	
fragment NestedImplementationElement*: 
	features+=Feature | connections+=Connection | bindings+=Binding | components+=Subcomponent |  ownedPropertyAssociations+=PropertyAssociation
;

fragment ConfigurationExtensions *:
	superClassifiers +=ClassifierOrTypeReference
	("," superClassifiers +=ClassifierOrTypeReference)*;

fragment ImplementationExtensions *:
	superClassifiers +=ImplementationReference
	("," superClassifiers +=ImplementationReference)*;

fragment InterfaceExtensions *:
	superClassifiers +=ReversableInterfaceReference
	("," superClassifiers +=ReversableInterfaceReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' assignedClassifiers+=ClassifierOrTypeReference (',' assignedClassifiers+=ClassifierOrTypeReference)*
;

Workingset returns av3::Workingset: 
	(private?='private')? 'workingset' name=QualifiedName 'is' 
	UseProps?
	 ( instanceRoots+=InstanceConfiguration )*  
	'end' ';'
;

InstanceConfiguration returns av3::InstanceConfiguration:
	{av3::InstanceConfiguration} name=ID ':' category=ComponentCategory
	typeReferences+=ClassifierOrTypeReference 
	(actions+=STRING)*
	(productlineConstraint=ProductLineConstraint)?
	';'
;

ProductLineConstraint returns av3::BinaryOperation:
	{av3::BinaryOperation}
	'plc' left=PropertyReference operator=SatisfiesOperation right=ListLiteral
;

// Behavior specification including error behavior


BehaviorAnnotationBlock returns av3::AnnotationBlock :
	'@' name=ID '{'
		BehaviorAnnotationElements
	 '}'';'
;

fragment BehaviorAnnotationElements*:
	BehaviorAnnotationElement*
;

fragment BehaviorAnnotationElement*:
	elements+= (Generator | Transition| Behavior | StateVariable )
;


StateVariable returns av3::StateVariable:
	(annotations+=Annotation )*
	name=ID ':' 'state' stateType=[av3::TypeDef|QualifiedName] 
	( '=' initialState=EnumerationLiteral)?	PropertiesBlock? ';'
;


Generator returns av3::Generator:
	(annotations+=Annotation )*
	name=ID ':'  type=ID? 'generator'  
	(value=ListLiteral)? InStates? PropertiesBlock? ';'
;


Transition returns av3::StateTransition :
	(annotations+=Annotation )*
	name=ID ':' 'transition' condition =  (MultiLiteralOperation | ModelElementContainsLiteral | ModelElementReference) '->' targetState=ModelElementEqualsEnumerationLiteral 
		(InStates)? PropertiesBlock? ';'
;

Behavior returns av3::Behavior :
	FlowPath | FlowSource  | TypedToken | ComputationalBehavior
;

FlowPath returns av3::Behavior :
	(annotations+=Annotation )*
	name=ID ':' 'flow' condition =(ListLiteral | ModelElementReference) '->'  ( sink?='sink' | (actions+=FlowOutput (',' actions+=FlowOutput)* ))
	(InStates )? PropertiesBlock?';'
;
FlowSource returns av3::Behavior :
	(annotations+=Annotation )*
	name=ID ':' 'flow'  source?='source' (condition =(ListLiteral | ModelElementReference)? '->' )?  actions+=FlowOutput (',' actions+=FlowOutput)* 
	(InStates )? PropertiesBlock?';'
;

FlowOutput returns av3::BinaryOperation:
	left= ModelElementReference 
;

TypedToken returns av3::Behavior :
	(annotations+=Annotation )*
	name=ID ':' 'token' source?='source'? condition =(MultiLiteralOperation | ModelElementContainsLiteral | ModelElementReference) 
		'->' ( sink?='sink'| TokenResultBlock )  
	( InStates )? PropertiesBlock?';'
;

ComputationalBehavior returns av3::Behavior :
	(annotations+=Annotation )*
	name=ID ':' 'behavior' condition =Literal '->'  TokenResultBlock 
	( InStates )? PropertiesBlock?';'
;

fragment TokenResultBlock* : 
actions+=TokenResult (',' actions+=TokenResult)* ;

TokenResult returns av3::BinaryOperation: TokenOutput | DetectionEvent;

TokenOutput returns av3::BinaryOperation:
	left= ModelElementReference (operator=EqualsOperation right=NamedElementReference)?
;

DetectionEvent returns av3::BinaryOperation:
	left= ModelElementReference operator=OutputOperation ( right=ListLiteral)?
;


ModelElementContainsLiteral returns av3::BinaryOperation:
	 left=ModelElementReference operator=InOperation right=ListLiteral
;

ModelElementContainsEnumerationLiteral returns av3::BinaryOperation:
	 left=ModelElementReference operator=InOperation right=EnumerationList
;

ModelElementEqualsLiteral returns av3::BinaryOperation:
	 left=ModelElementReference operator=EqualsOperation right=NamedElementReference
;

ModelElementEqualsEnumerationLiteral returns av3::BinaryOperation:
	 left=ModelElementReference operator=EqualsOperation right=EnumerationLiteral
;

FeatureInput returns av3::BinaryOperation:
	 left=ModelElementReference operator=InputOperation 
;

// Annotations

Annotation returns av3::Annotation :
	'@' name=ID ( '(' parameters+= AnnotationParameter (',' parameters+= AnnotationParameter)*')')?
;

AnnotationParameter returns av3::NameValuePair:
	name=ID '=' value=Literal
;

// expression/constraint language

Literal returns av3::Literal:
	IntegerLiteral | RealLiteral | StringLiteral | BooleanLiteral | PropertyReference  | DirectionalLiteral | ListLiteral 
	| SetLiteral | MultiLiteralOperation
	| ModelElementContainsLiteral   | NamedElementReference | EnumerationLiteral //| FeatureInput
;


PackageElementReference returns av3::PackageElementReference :  
	 element=[av3::PackageElement|QualifiedName]
;

PropertyReference returns av3::PackageElementReference :  
	'#' element=[av3::PackageElement|QualifiedName]
;

IntegerLiteral returns av3::Literal:
	{av3::IntegerLiteral} value=INT unit=ID?
;

RealLiteral returns av3::Literal:
	{av3::RealLiteral} value=DOUBLE unit=ID?
;

terminal DOUBLE returns ecore::EDouble: ('0'..'9')+ '.' ('0'..'9')+;

StringLiteral returns av3::Literal:
	{av3::StringLiteral} value=NoQuoteString
;

EnumerationLiteral returns av3::EnumerationLiteral:
	{av3::EnumerationLiteral} name=ID
;

NoQuoteString :
	// remove quotes from string in ValueConverter
	STRING
;

BooleanLiteral returns av3::Literal:
	{av3::BooleanLiteral} (value?='true'|'false')
;

ListLiteral returns av3::ListLiteral:
	{av3::ListLiteral} '(' (elements+=Literal (',' elements+=Literal)*)? ')'
;

EnumerationList returns av3::ListLiteral:
	{av3::ListLiteral} '(' (elements+=EnumerationLiteral (',' elements+=EnumerationLiteral)*)? ')'
;

SetLiteral returns av3::SetLiteral:
	{av3::SetLiteral} '{' (elements+=Literal (',' elements+=Literal)*)? '}'
;

DirectionalLiteral returns av3::DirectionalLiteral:
	{av3::DirectionalLiteral}direction=PropagationDirection value=Literal
;


MultiLiteralOperation returns av3::MultiLiteralConstraint:
	{av3::MultiLiteralConstraint} operator=EOperation '(' (elements+=Literal (',' elements+=Literal)*)? ')'
;


QualifiedNameWithWildcard:
	QualifiedName '::*';

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('::' ID)*;

QualifiedTypesReference:
	QualifiedName ('.'ID)?;

QualifiedReference:
	QualifiedName;

QualifiedDottedReference:
	QualifiedName '.' ID;

ComponentCategory returns av3::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | 'parameter' | DataAccessKeywords 
	| BusAccessKeywords | VirtualBusAccessKeywords | SubprogramAccessKeywords | SubprogramGroupAccessKeywords
	| 'binding' | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;

PropagationDirection returns av3::FeatureDirection:
	'in' | 'out' ;

Composite returns av3::Composite:
	'list' | 'set' ;

Primitive returns av3::Primitive:
	'boolean' | 'integer' | 'real' | 'string' ;
	

EOperation returns av3::EOperator:
	'any' | 'all' | 'oneof' | 'of' | 'ormore' | 'orless' ;

BinaryOperation returns av3::BinaryOperator:
	'in' | 'contains' | 'equals'  | 'satisfies' | '!' | '?';

SatisfiesOperation returns av3::BinaryOperator:
	 'satisfies' ;

EqualsOperation returns av3::BinaryOperator:
	 '=' ;

InOperation returns av3::BinaryOperator:
	 'in' ;

InputOperation returns av3::BinaryOperator:
	 '?' ;

OutputOperation returns av3::BinaryOperator:
	 '!' ;
	
AssociationType returns  av3::AssociationType:
	IsConnection | IsBinding | IsFlow 
;

IsConnection returns av3::AssociationType:
	'connection' ;

IsBinding returns av3::AssociationType:
	'binding' ;

IsFlow returns av3::AssociationType:
	'flow' ;


VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

EndToEndFLowKeywords: 'end''to''end''flow';
FlowSourceKeywords: 'flow''source';
FlowSinkKeywords: 'flow''sink';
//FlowPathKeywords: 'flow';

InOutKeywords: 'in''out'; 
BusAccessKeywords: 'bus''access' ; 
VirtualBusAccessKeywords: 'virtual''bus''access' ; 
DataAccessKeywords: 'data''access' ; 
SubprogramAccessKeywords: 'subprogram''access' ; 
SubprogramGroupAccessKeywords: 'subprogram''group''access' ; 

ProvidesReadKeywords: 'provides' 'in';
RequiresReadKeywords: 'requires' 'in';
ProvidesWriteKeywords: 'provides' 'out';
RequiresWriteKeywords: 'requires' 'out';
ProvidesRWKeywords: 'provides' 'in''out';
RequiresRWKeywords: 'requires' 'in''out';

        
terminal ANNEXTEXT:
	'{*' -> '*}';
        