// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	'package' name=QualifiedName 
	imports+=Import*
	elements+=(PackageDeclaration | PrimitiveType | ComponentInterface | ComponentImplementation | ComponentConfiguration | Property | PropertySet | Workingset)*
	'end' SEMICOLON;


Property returns av3::Property:
	'property' name=ID type=[av3::Type|QualifiedName] SEMICOLON;

PropertySet returns av3::PropertySet:
	'properties' name=ID  
		properties += [av3::Property|QualifiedName] (',' properties += [av3::Property|QualifiedName])*
		'end' SEMICOLON
;

PrimitiveType returns av3::PrimitiveType:
	'type' name=ID PropertiesBlock? SEMICOLON;

ComponentInterface returns av3::ComponentInterface:
	(private?='private')? category=ComponentCategory? 'interface'  name=ID ('extends' (InterfaceExtensions)?)? 
	 InterfaceBody?
	('use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* SEMICOLON)?
	'end' SEMICOLON;

fragment InterfaceBody*:
	'is' (features+=Feature | flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink | propertyAssociations+=PropertyAssociation)*
;

ComponentImplementation returns av3::ComponentImplementation:
	(private?='private')? category=ComponentCategory name=QualifiedName 
	('extends' (ImplementationExtensions)?)? 
	 ImplementationBody? 
	'end'  SEMICOLON;

fragment ImplementationBody*:
	'is' (connections+=Connection |connections+=FeatureMapping | components+=Component | paths+= Path | flowAssignments+=FlowAssignment | assignments+=ConfigurationAssignment| propertyAssociations+=PropertyAssociation)*
;

ComponentConfiguration returns av3::ComponentConfiguration:
	(private?='private')? 'configuration' name=QualifiedName  
	Parameters?
	'extends' ClassifierExtensions ConfigurationElementBlock? 
	'end'  SEMICOLON;
	

// (Instance) model elements

Feature returns av3::Feature:
	name=ID ':' direction=FeatureDirection? sampled?='sampled'? category=FeatureCategory 
	reverse?='reverse'? type=[av3::Type|QualifiedName]? PropertiesBlock?
	SEMICOLON;

Component returns av3::Component:
	name=ID ':' category=ComponentCategory
	typeReference=TypeReference? NestedComponentImplementationBlock?
 SEMICOLON;

Connection returns av3::Association:
	name=ID ':' associationType=ConnectionType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? SEMICOLON;

FeatureMapping returns av3::Association:
	name=ID ':' associationType=MappingType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? SEMICOLON;


FlowPath returns av3::Association:
	name=ID ':' associationType=FlowPathType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? SEMICOLON;

FlowSource returns av3::Association:
	name=ID ':' associationType=FlowSourceType '->' destination=ModelElementReference  PropertiesBlock? SEMICOLON;

FlowSink returns av3::Association:
	name=ID ':' associationType=FlowSinkType  source=ModelElementReference '->'
	 PropertiesBlock? SEMICOLON;


Path returns av3::PathSequence:
	name=ID ':' EndToEndFlowKeywords elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? SEMICOLON;


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' importedNamespace=QualifiedNameWithWildcard SEMICOLON;

ConfigurationAssignment returns av3::ConfigurationAssignment:
	target= ModelElementReference '=>' 
	((value=TypeReference (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	SEMICOLON;


FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	SEMICOLON;


PropertyAssociation returns av3::PropertyAssociation:
	target=PropertyReference  '=>' 
	value=PropertyValue SEMICOLON;

PropertyValue returns av3::PropertyValue:
	 value=INT
;

ModelElementReference returns av3::ModelElementReference:
	element=[av3::ModelElement|ID] => ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


PropertyReference returns av3::ModelElementReference: 
	(element=[av3::ModelElement|ID] => ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*)? '#' property=[av3::Property|QualifiedName] 
		;

fragment ConfigurationElementBlock *:
	'is' ( propertyAssociations+=PropertyAssociation | assignments+=ConfigurationAssignment )+;

fragment CurlyConfigurationElementBlock *:
	'{' (propertyAssociations+=PropertyAssociation | assignments+=ConfigurationAssignment )* '}';

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName] ;


// reference objects for classifiers including configurations with parameter

ReversableInterfaceReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::ComponentInterface|QualifiedName] ;

TypeReference returns av3::TypeReference :  
	 type=[av3::Type|QualifiedName]
	  ConfigurationActuals?
;

ImplementationReference returns av3::TypeReference :  
	 type=[av3::ComponentImplementation|QualifiedName]
;

fragment PropertiesBlock *:
	'{' propertyAssociations+=PropertyAssociation* '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{' (features+=Feature | connections+=Connection| connections+=FeatureMapping  | components+=Component |  propertyAssociations+=PropertyAssociation)* '}';



fragment ClassifierExtensions *:
	superClassifiers +=TypeReference
	("," superClassifiers +=TypeReference)*;

fragment ImplementationExtensions *:
	superClassifiers +=ImplementationReference
	("," superClassifiers +=ImplementationReference)*;


fragment InterfaceExtensions *:
	superClassifiers +=ReversableInterfaceReference
	("," superClassifiers +=ReversableInterfaceReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' value=TypeReference
;

Workingset returns av3::Workingset: 
	'workingset' name=QualifiedName 'is' rootComponents+=Component* 'end' SEMICOLON?
;



QualifiedNameWithWildcard:
	QualifiedName '.*'?;

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('.' ID)*;

SEMICOLON:
	';';


ComponentCategory returns av3::ComponentCategory: 'component' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | 'access' 
	|BusAccessKeywords | 'binding' | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;


ConnectionType returns av3::AssociationType:
	'connection'| 'binding' ;

MappingType returns av3::AssociationType:
	'mapping' ;

FlowPathType returns av3::AssociationType:
	FlowPathKeywords ;

FlowSourceType returns av3::AssociationType:
	FlowSourceKeywords ;

FlowSinkType returns av3::AssociationType:
	FlowSinkKeywords ;


VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

EndToEndFlowKeywords: 'end''to''end''flow';
FlowSourceKeywords: 'flow';//'source';
FlowSinkKeywords: 'flow';//'sink';
FlowPathKeywords: 'flow';//'path';

InOutKeywords: 'in' 'out'; 
BusAccessKeywords: 'bus''access' ; 

ProvidesReadKeywords: 'provides' 'read';
RequiresReadKeywords: 'requires' 'read';
ProvidesWriteKeywords: 'provides' 'write';
RequiresWriteKeywords: 'requires' 'write';
ProvidesRWKeywords: 'provides' 'readwrite';
RequiresRWKeywords: 'requires' 'readwrite';
        
