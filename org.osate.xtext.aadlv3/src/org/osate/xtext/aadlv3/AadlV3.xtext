// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	'package' name=QualifiedName 
	imports+=Import*
	elements+=(PackageDeclaration | DataType | ComponentInterface | ComponentImplementation | ComponentConfiguration | Property | PropertySet | Workingset)*
	'end' SEMICOLON;


Property returns av3::Property:
	'property' name=ID ':' type=[av3::Type|QualifiedReference] SEMICOLON;

PropertySet returns av3::PropertySet:
	'properties' name=ID  ':'
		'{' properties += [av3::Property|QualifiedReference] (',' properties += [av3::Property|QualifiedName])* '}'
	SEMICOLON
;

DataType returns av3::DataType:
	'type' name=ID PropertiesBlock? SEMICOLON;

ComponentInterface returns av3::ComponentInterface:
	(private?='private')? category=ComponentCategory? 'interface'  name=ID ('extends' (InterfaceExtensions)?)? 
	 InterfaceBody
	SEMICOLON;

fragment InterfaceBody*:
	('is' InterfaceElement (SEMICOLON InterfaceElement)* SEMICOLON? )? 'end'
;
fragment InterfaceElement*:
	 features+=Feature | flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink | propertyAssociations+=PropertyAssociation | UseProps
;
	
//fragment SectionsInterfaceBody*:
//	('features' features+=Feature+)?
//	&('flows' (flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink)+)?
// 	&('properties' propertyAssociations+=PropertyAssociation+ )?
//;

ComponentImplementation returns av3::ComponentImplementation:
	(private?='private')? category=ComponentCategory name=DottedName 
	('extends' (ImplementationExtensions)?)? 
	 ImplementationBody
	  SEMICOLON;

fragment ImplementationBody*:
	('is'
		ImplementationElement (SEMICOLON ImplementationElement)* SEMICOLON? )? 
	'end'
;

fragment ImplementationElement* :
	connections+=Connection |connections+=FeatureMapping | components+=Component 
		| paths+= Path | flowAssignments+=FlowAssignment | configurationAssignments+=ConfigurationAssignment
		| propertyAssociations+=PropertyAssociation
;

//fragment SectionsImplementationBody*:
//	('subcomponents'(components+=Component|assignments+=ConfigurationAssignment)+ )?
// 	&('connections' connections+=(Connection|FeatureMapping)+ )?
// 	&('flows' (flowAssignments+=FlowAssignment| paths+= Path )+)?
// 	&('properties' propertyAssociations+=PropertyAssociation+ )?
//;

ComponentConfiguration returns av3::ComponentConfiguration:
	(private?='private')? 'configuration' name=DottedName  
	Parameters?
	'extends' ConfigurationExtensions ConfigurationElementBlock 
	 SEMICOLON;
	

// (Instance) model elements

Feature returns av3::Feature:
	name=ID ':' direction=FeatureDirection? sampled?='sampled'? 
	category=FeatureCategory 
	(reverse?='reverse'? 
	type=[av3::Type|QualifiedName] )?
	PropertiesBlock?
	;

Component returns av3::Component:
	name=ID ':' category=ComponentCategory
	(typeReferences+=TypeReference (',' typeReferences+=TypeReference?)*)?
	NestedComponentImplementationBlock?
 ;

Connection returns av3::Association:
	name=ID ':' associationType=ConnectionType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ;

FeatureMapping returns av3::Association:
	name=ID ':' associationType=MappingType source=ModelElementReference
	'=>' destination=ModelElementReference PropertiesBlock? ;


FlowPath returns av3::Association:
	name=ID ':' associationType=FlowPathType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ;

FlowSource returns av3::Association:
	name=ID ':' associationType=FlowSourceType  destination=ModelElementReference  PropertiesBlock? ;

FlowSink returns av3::Association:
	name=ID ':' associationType=FlowSinkType  source=ModelElementReference 
	 PropertiesBlock? ;

fragment UseProps*:	
	'use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* 
;


Path returns av3::PathSequence:
	name=ID ':' EndToEndFlowKeywords elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? ;


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' (importedNamespace=QualifiedNameWithWildcard |
		(importedNamespace=QualifiedName ('as' alias=ID)?)
	) 
	SEMICOLON;

ConfigurationAssignment returns av3::ConfigurationAssignment:
	target= ModelElementReference '=>' 
	((assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	;


FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	;


PropertyAssociation returns av3::PropertyAssociation:
	(target=ModelElementReference)? '#' property=[av3::Property|QualifiedName] 
	propertyAssociationType=PropertyAssociationType?
	'=>' value=PropertyValue ;

PropertyValue returns av3::PropertyValue:
	 value=INT
;

ModelElementReference returns av3::ModelElementReference:
	element=[av3::ModelElement|ID] => ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


fragment ConfigurationElementBlock *:
	('is' ConfigurationElement (SEMICOLON ConfigurationElement )* SEMICOLON? )? 'end';

fragment CurlyConfigurationElementBlock *:
	'{' ConfigurationElement (SEMICOLON ConfigurationElement )* SEMICOLON? '}';

fragment ConfigurationElement*: 
	propertyAssociations+=PropertyAssociation | configurationAssignments+=ConfigurationAssignment
;

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName] ;


// reference objects for classifiers including configurations with parameter

ReversableInterfaceReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::ComponentInterface|QualifiedReference] ;

TypeReference returns av3::TypeReference :  
	 type=[av3::Type|QualifiedTypesReference]
	  ConfigurationActuals?
;

RealizationReference returns av3::TypeReference :  
	 type=[av3::ComponentRealization|QualifiedDottedReference]
	  ConfigurationActuals?
;

ImplementationReference returns av3::TypeReference :  
	 type=[av3::ComponentImplementation|QualifiedDottedReference]
;

fragment PropertiesBlock *:
	'{' propertyAssociations+=PropertyAssociation (SEMICOLON propertyAssociations+=PropertyAssociation)* SEMICOLON? '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{' NestedImplementationElement (SEMICOLON NestedImplementationElement)* SEMICOLON?
	 	'}';
	 	
fragment NestedImplementationElement*: 
	features+=Feature | connections+=Connection| connections+=FeatureMapping  | components+=Component |  propertyAssociations+=PropertyAssociation
;

fragment ConfigurationExtensions *:
	superClassifiers +=RealizationReference
	("," superClassifiers +=RealizationReference)*;

fragment ImplementationExtensions *:
	superClassifiers +=ImplementationReference
	("," superClassifiers +=ImplementationReference)*;

fragment InterfaceExtensions *:
	superClassifiers +=ReversableInterfaceReference
	("," superClassifiers +=ReversableInterfaceReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)*
;

Workingset returns av3::Workingset: 
	'workingset' name=QualifiedName 'is' rootComponents+=Component (SEMICOLON rootComponents+=Component)* SEMICOLON? 'end' SEMICOLON
;



QualifiedNameWithWildcard:
	QualifiedName '::*';

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('::' ID)*;

QualifiedTypesReference:
	QualifiedName ('.'ID)?;

QualifiedReference:
	QualifiedName;

QualifiedDottedReference:
	QualifiedName '.' ID;

SEMICOLON:
	';';


ComponentCategory returns av3::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | 'access' 
	|BusAccessKeywords | 'binding' | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;


ConnectionType returns av3::AssociationType:
	'connection'| 'binding' ;

MappingType returns av3::AssociationType:
	'mapping' ;

FlowPathType returns av3::AssociationType:
	FlowPathKeywords ;

FlowSourceType returns av3::AssociationType:
	FlowSourceKeywords ;

FlowSinkType returns av3::AssociationType:
	FlowSinkKeywords ;

PropertyAssociationType returns av3::PropertyAssociationType:
	'final' | 'default' | 'override'
;

VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

EndToEndFlowKeywords: 'end''to''end''flow';
FlowSourceKeywords: 'flow''source';
FlowSinkKeywords: 'flow''sink';
FlowPathKeywords: 'flow''path';

InOutKeywords: 'in' 'out'; 
BusAccessKeywords: 'bus''access' ; 

ProvidesReadKeywords: 'provides' 'read';
RequiresReadKeywords: 'requires' 'read';
ProvidesWriteKeywords: 'provides' 'write';
RequiresWriteKeywords: 'requires' 'write';
ProvidesRWKeywords: 'provides' 'readwrite';
RequiresRWKeywords: 'requires' 'readwrite';
        
