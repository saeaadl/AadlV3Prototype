// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	(private?='private')? 'package' name=QualifiedName 
	(imports+=Import |
	elements+= PackageElement)*
	'end' ;

PackageElement returns av3::PackageElement:
	PackageDeclaration | DataType | ComponentInterface | ComponentImplementation | ComponentConfiguration | PropertyDefinition | PropertySet | Workingset
;

PropertyDefinition returns av3::PropertyDefinition:
	(private?='private')? 'property' name=ID ':' type=[av3::Type|QualifiedReference] 
	('for' AppliesTo (',' AppliesTo)*)? 
	SEMICOLON;

fragment AppliesTo*:
	componentCategories+=ComponentCategory | featureCategories+=FeatureCategory 
		| associationTypes+=AssociationType
	
;

PropertySet returns av3::PropertySet:
	(private?='private')? 'properties' name=ID  ':'
		'{' properties += [av3::PropertyDefinition|QualifiedReference] (',' properties += [av3::PropertyDefinition|QualifiedName])* '}'
	SEMICOLON
;

DataType returns av3::DataType:
	(private?='private')? 'type' name=ID PropertiesBlock? SEMICOLON;

ComponentInterface returns av3::ComponentInterface:
	(private?='private')? category=ComponentCategory? 'interface'  name=ID ('extends' (InterfaceExtensions)?)? 
	 InterfaceBody
	;

fragment InterfaceBody*:
	('is' InterfaceElement (SEMICOLON InterfaceElement)* SEMICOLON? )? 'end'
;
fragment InterfaceElement*:
	 features+=Feature | flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink | propertyAssociations+=PropertyAssociation | UseProps
;
	
//fragment SectionsInterfaceBody*:
//	('features' features+=Feature+)?
//	&('flows' (flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink)+)?
// 	&('properties' propertyAssociations+=PropertyAssociation+ )?
//;

ComponentImplementation returns av3::ComponentImplementation:
	(private?='private')? category=ComponentCategory name=DottedName 
	('extends' (ImplementationExtensions)?)? 
	 ImplementationBody
	  ;

fragment ImplementationBody*:
	('is'
		ImplementationElement (SEMICOLON ImplementationElement)* SEMICOLON? )? 
	'end'
;

fragment ImplementationElement* :
	connections+=Connection |connections+=FeatureDelegate | bindings+=Binding | components+=Component 
		| paths+= Path | flowAssignments+=FlowAssignment | configurationAssignments+=ConfigurationAssignment | configurationAssignments+=ConfigurationAssignmentPattern
		| propertyAssociations+=PropertyAssociation
;

//fragment SectionsImplementationBody*:
//	('subcomponents'(components+=Component|assignments+=ConfigurationAssignment)+ )?
// 	&('connections' connections+=(Connection|FeatureMapping)+ )?
// 	&('flows' (flowAssignments+=FlowAssignment| paths+= Path )+)?
// 	&('properties' propertyAssociations+=PropertyAssociation+ )?
//;

ComponentConfiguration returns av3::ComponentConfiguration:
	(private?='private')? 'configuration' name=DottedName  
	Parameters?
	'extends' ConfigurationExtensions ConfigurationElementBlock 
	 ;
	

// (Instance) model elements

Feature returns av3::Feature:
	name=ID ':' direction=FeatureDirection?  
	category=FeatureCategory 
	(typeReference=ReversableTypeReference )?
	PropertiesBlock?
	;

Component returns av3::Component:
	name=ID ':' category=ComponentCategory
	(typeReferences+=TypeReference 
		//(',' typeReferences+=TypeReference?)*
	)?
	NestedComponentImplementationBlock?
 ;

Connection returns av3::Association:
	name=ID ':' associationType=ConnectionType source=ModelElementReference
	(directional?='->'|'<->') destination=ModelElementReference PropertiesBlock? ;

FeatureDelegate returns av3::Association:
	name=ID ':' associationType=DelegateType source=ModelElementReference
	(directional?='->'|'<->') destination=ModelElementReference PropertiesBlock? ;


Binding returns av3::Association:
	name=ID ':' associationType=BindingType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ;


FlowPath returns av3::Association:
	name=ID ':' associationType=FlowPathType source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ;

FlowSource returns av3::Association:
	name=ID ':' associationType=FlowSourceType  destination=ModelElementReference  PropertiesBlock? ;

FlowSink returns av3::Association:
	name=ID ':' associationType=FlowSinkType  source=ModelElementReference 
	 PropertiesBlock? ;

fragment UseProps*:	
	'use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* 
;


Path returns av3::PathSequence:
	name=ID ':' EndToEndFlowKeywords elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? ;


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' (importedNamespace=QualifiedNameWithWildcard | importedNamespace=QualifiedName)
	('as' alias=ID)?
	SEMICOLON;

ConfigurationAssignment returns av3::ConfigurationAssignment:
	target= ModelElementReference '=>' 
	((assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	;

ConfigurationAssignmentPattern returns av3::ConfigurationAssignmentPattern:
	targetPattern = [av3::Type|QualifiedTypesReference] '*=>' 
	((assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	;


FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	;


PropertyAssociation returns av3::PropertyAssociation:
	(target=ModelElementReference)? '#' property=[av3::PropertyDefinition|QualifiedName] 
	propertyAssociationType=PropertyAssociationType?
	'=>' value=PropertyValue ;

PropertyValue returns av3::PropertyValue:
	 value=INT unit=ID?
;

ModelElementReference returns av3::ModelElementReference:
	element=[av3::ModelElement|ID] => ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


fragment ConfigurationElementBlock *:
	('is' ConfigurationElement (SEMICOLON ConfigurationElement )* SEMICOLON? )? 'end';

fragment CurlyConfigurationElementBlock *:
	'{' ConfigurationElement (SEMICOLON ConfigurationElement )* SEMICOLON? '}';

fragment ConfigurationElement*: 
	propertyAssociations+=PropertyAssociation | bindings+=Binding | configurationAssignments+=ConfigurationAssignment | configurationAssignments+=ConfigurationAssignmentPattern
;

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName] ;


// reference objects for classifiers including configurations with parameter

ReversableInterfaceReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::ComponentInterface|QualifiedReference] ;

ReversableTypeReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::Type|QualifiedReference] ;

TypeReference returns av3::TypeReference :  
	 type=[av3::Type|QualifiedTypesReference]
	  ConfigurationActuals?
;

RealizationReference returns av3::TypeReference :  
	 type=[av3::ComponentRealization|QualifiedDottedReference]
	  ConfigurationActuals?
;

ImplementationReference returns av3::TypeReference :  
	 type=[av3::ComponentImplementation|QualifiedDottedReference]
;

fragment PropertiesBlock *:
	'{' propertyAssociations+=PropertyAssociation (SEMICOLON propertyAssociations+=PropertyAssociation)* SEMICOLON? '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{' NestedImplementationElement (SEMICOLON NestedImplementationElement)* SEMICOLON?
	 	'}';
	 	
fragment NestedImplementationElement*: 
	features+=Feature | connections+=Connection| connections+=FeatureDelegate | bindings+=Binding | components+=Component |  propertyAssociations+=PropertyAssociation
;

fragment ConfigurationExtensions *:
	superClassifiers +=RealizationReference
	("," superClassifiers +=RealizationReference)*;

fragment ImplementationExtensions *:
	superClassifiers +=ImplementationReference
	("," superClassifiers +=ImplementationReference)*;

fragment InterfaceExtensions *:
	superClassifiers +=ReversableInterfaceReference
	("," superClassifiers +=ReversableInterfaceReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)*
;

Workingset returns av3::Workingset: 
	(private?='private')? 'workingset' name=QualifiedName 'is' 
	UseProps?
	rootComponents+=Component (SEMICOLON rootComponents+=Component)* SEMICOLON? 
	'end' 
;



QualifiedNameWithWildcard:
	QualifiedName '::*';

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('::' ID)*;

QualifiedTypesReference:
	QualifiedName ('.'ID)?;

QualifiedReference:
	QualifiedName;

QualifiedDottedReference:
	QualifiedName '.' ID;

SEMICOLON:
	';';


ComponentCategory returns av3::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | DataAccessKeywords 
	| BusAccessKeywords | VirtualBusAccessKeywords | SubprogramAccessKeywords | SubprogramGroupAccessKeywords
	| BindingPointKeywords | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;

AssociationType returns  av3::AssociationType:
	ConnectionType | BindingType | DelegateType |  FlowType
;

ConnectionType returns av3::AssociationType:
	'connection' ;

BindingType returns av3::AssociationType:
	'binding' ;

DelegateType returns av3::AssociationType:
	'delegate' ;

FlowPathType returns av3::AssociationType:
	FlowPathKeywords ;

FlowSourceType returns av3::AssociationType:
	FlowSourceKeywords ;

FlowSinkType returns av3::AssociationType:
	FlowSinkKeywords ;

FlowType returns av3::AssociationType:
	'flow' ;


PropertyAssociationType returns av3::PropertyAssociationType:
	'final' | 'default' | 'override'
;

VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

EndToEndFlowKeywords: 'end''to''end''flow';
FlowSourceKeywords: 'flow''source';
FlowSinkKeywords: 'flow''sink';
FlowPathKeywords: 'flow''path';

InOutKeywords: 'in''out'; 
BusAccessKeywords: 'bus''access' ; 
VirtualBusAccessKeywords: 'virtual''bus''access' ; 
DataAccessKeywords: 'data''access' ; 
SubprogramAccessKeywords: 'subprogram''access' ; 
SubprogramGroupAccessKeywords: 'subprogram''group''access' ; 
BindingPointKeywords: 'binding''point' ; 

ProvidesReadKeywords: 'provides' 'in';
RequiresReadKeywords: 'requires' 'in';
ProvidesWriteKeywords: 'provides' 'out';
RequiresWriteKeywords: 'requires' 'out';
ProvidesRWKeywords: 'provides' 'in''out';
RequiresRWKeywords: 'requires' 'in''out';
        
