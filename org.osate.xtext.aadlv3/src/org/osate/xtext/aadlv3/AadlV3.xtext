// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	 (annotations += Annotation )*
	(private?='private')? 'package' name=QualifiedName 'is'
	
	( elements+=AnnexLibrary |
	(imports+=Import |
	elements+= PackageElement)*
	)
	'end' ';';

AnnexLibrary returns av3::AnnexLibrary :
	'@' name=ID '{' '}'
;

PackageElement returns av3::PackageElement:
	 (PackageDeclaration  | ComponentInterface | ComponentImplementation | ComponentConfiguration | PropertyDefinition | PropertySet | Workingset
	| TypeDef | ConstantDef )
	;

PropertyDefinition returns av3::PropertyDefinition:
	 (annotations += Annotation )*
	(private?='private')? 'property' name=ID ':' type=Type
	('for' '(' ( forAll?='all' | (AppliesTo (',' AppliesTo)*)) ')'  )? 
	';' ;

fragment AppliesTo*:
	componentCategories+=ComponentCategory | featureCategories+=FeatureCategory 
		| associationTypes+=AssociationType 
	
;

PropertySet returns av3::PropertySet:
	 (annotations += Annotation )*
	(private?='private')? 'properties' name=ID  ':'
		'{' properties += [av3::PropertyDefinition|QualifiedReference] (',' properties += [av3::PropertyDefinition|QualifiedName])* '}'
	';'
;

TypeDef returns av3::TypeDef:
	 (annotations += Annotation )*
	(private?='private')? 'type' name=ID ('extends' superType=Type)?
	(':' baseType=Type)?
		PropertiesBlock? ';'
;


ConstantDef returns av3::Constant:
	 (annotations += Annotation )*
	(private?='private')? 'constant' name=ID ':' value=Literal
		';'
;


PropertyAssociation returns av3::PropertyAssociation:
	 ( target=ModelElementReference)? 
	 '#' property=[av3::PropertyDefinition|QualifiedName] 
	propertyAssociationType=PropertyAssociationType value=Literal
	 ';'
	;

PropertyAssociationType returns av3::PropertyAssociationType:
	'=>' | '=' | '*=>' 
;

ModelElementReference returns av3::NamedElementReference:
	// => or -> both work
	element=[av3::ModelElement|ID] -> ({av3::NamedElementReference.context=current} '.' element=[av3::ModelElement|ID])*;

NamedElementReference returns av3::NamedElementReference:
	// => or -> both work
	element=[av3::NamedElement|QualifiedReference] -> ({av3::NamedElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


ComponentInterface returns av3::ComponentInterface:
	 (annotations += Annotation )*
	(private?='private')? category=ComponentCategory? 'interface'  name=ID ('extends' InterfaceExtensions)? 
	 InterfaceBody ';'
	;

fragment InterfaceBody*:
	'is' (InterfaceElement )*  'end'
;
fragment InterfaceElement*:
	 features+=Feature 
	 | flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink 
	| stateVariables+= StateVariable | behaviorRules +=TransitionRule | behaviorRules +=BFlowRule| generators += Event
	  | ownedPropertyAssociations+=PropertyAssociation | annexSubclause+=AnnexSubclause
;
	

ComponentImplementation returns av3::ComponentImplementation:
	 (annotations += Annotation )*
	(private?='private')? category=ComponentCategory name=DottedName 
	('extends' ImplementationExtensions)? 
	 ImplementationBody ';'
	  ;

fragment ImplementationBody*:
	'is' (ImplementationElement )* 	'end'
;

fragment ImplementationElement* :
	connections+=Connection |
	 bindings+=Binding | components+=Subcomponent 
		| paths+= Path | flowAssignments+=FlowAssignment | classifierAssignments+=ClassifierAssignment | classifierAssignments+=ClassifierAssignmentPattern
		| stateVariables+= StateVariable | behaviorRules +=TransitionRule | behaviorRules +=BFlowRule| generators += Event
		| ownedPropertyAssociations+=PropertyAssociation | annexSubclause+=AnnexSubclause
;

ComponentConfiguration returns av3::ComponentConfiguration:
	 (annotations += Annotation )*
	(private?='private')? 'configuration' name=DottedName  
	Parameters?
	// optional extension. If no extends then we have a generic configuration with patterns
	('extends' ConfigurationExtensions)? ConfigurationElementBlock ';'
	 ;
	

// (Instance) model elements

Feature returns av3::Feature:
	 (annotations += Annotation )*
	name=ID ':' direction=FeatureDirection?  
	category=FeatureCategory 
	(typeReference=ReversableTypeReference )?
	PropertiesBlock? ';'
	;

Subcomponent returns av3::Subcomponent:
{av3::Subcomponent}	 (annotations += Annotation )*
	name=ID ':' category=ComponentCategory
	( typeReferences+=ClassifierOrTypeReference 
		//(',' typeReferences+=TypeReference?)* 
		)?
	NestedComponentImplementationBlock? 
	InModes? ';'
 ;

Connection returns av3::Association:
	name=ID ':' associationType=IsConnection source=ModelElementReference
	('->'|bidirectional?='<->') destination=ModelElementReference PropertiesBlock? InModes? ';';


Binding returns av3::Association:
	name=ID ':' bindingType=[av3::TypeDef|QualifiedName]? associationType=IsBinding 
	source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? InModes? ';';


FlowPath returns av3::Association:
	name=ID ':' associationType=IsFlow source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ';';

FlowSource returns av3::Association:
	name=ID ':' associationType=IsFlowSource  destination=ModelElementReference  PropertiesBlock? ';' ;

FlowSink returns av3::Association:
	name=ID ':' associationType=IsFlowSink  source=ModelElementReference 
	 PropertiesBlock? ';';

fragment UseProps*:	
	'use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* 
	';'
;

fragment InModes*:	
	'when' inModes = ModelElementContainsLiteral
;

Path returns av3::PathSequence:
	name=ID ':' 'flow' elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? ';';


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' (importedNamespace=QualifiedNameWithWildcard | importedNamespace=QualifiedName)
	('as' alias=ID)?
	';';

ClassifierAssignment returns av3::ClassifierAssignment:
	target= ModelElementReference '=>' 
	((assignedClassifiers+=ClassifierOrTypeReference (',' assignedClassifiers+=ClassifierOrTypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	';'
	;

ClassifierAssignmentPattern returns av3::ClassifierAssignmentPattern:
	QueryExpression '=>' 
	((assignedClassifiers+=ClassifierOrTypeReference (',' assignedClassifiers+=ClassifierOrTypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	';'
	;

fragment QueryExpression *: 
'all''('targetPattern = [av3::Type|QualifiedTypesReference] ')';

FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	';'
	;



fragment ConfigurationElementBlock *:
	'is' (ConfigurationElement )* 'end';

fragment CurlyConfigurationElementBlock *:
	'{' (ConfigurationElement  )+ '}'; 

fragment ConfigurationElement*: 
	ownedPropertyAssociations+=PropertyAssociation | 
	bindings+=Binding | classifierAssignments+=ClassifierAssignment | classifierAssignments+=ClassifierAssignmentPattern | annexSubclause+=AnnexSubclause
;

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName];


// reference objects for classifiers including configurations with parameter

ReversableInterfaceReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::ComponentInterface|QualifiedReference] ;

ReversableTypeReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::NamedType|QualifiedReference] ;

ClassifierOrTypeReference returns av3::TypeReference :  
	 type=[av3::NamedType|QualifiedTypesReference]
	  ConfigurationActuals?
;

TypeReference returns av3::TypeReference :  
	 type=[av3::NamedType|QualifiedName]
;

Type returns av3::Type :  
	 TypeReference | CompositeType | PrimitiveType | EnumerationType
;

EnumerationType returns av3::EnumerationType :
	{av3::EnumerationType} 'enum' '(' literals+=EnumerationLiteral* ')'
;

CompositeType returns av3::CompositeType:
	compositeType=Composite 'of' type=TypeReference
;

PrimitiveType returns av3::PrimitiveType:
	primitiveType=Primitive
;

RealizationReference returns av3::TypeReference :  
	 type=[av3::ComponentRealization|QualifiedDottedReference]
	  ConfigurationActuals?
;

ImplementationReference returns av3::TypeReference :  
	 type=[av3::ComponentImplementation|QualifiedDottedReference]
;

AnnexSubclause returns av3::AnnexSubclause :
	BehaviorSpecification  
	| DefaultAnnexSubclause
;

DefaultAnnexSubclause returns av3::DefaultAnnexSubclause :
	'@' name=ID  body=ANNEXTEXT ';'
;


fragment PropertiesBlock *:
	'{' (ownedPropertyAssociations+=PropertyAssociation )+ '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{'  ( NestedImplementationElement )+ 
	 	'}';
	 	
fragment NestedImplementationElement*: 
	features+=Feature | connections+=Connection | bindings+=Binding | components+=Subcomponent |  ownedPropertyAssociations+=PropertyAssociation
;

fragment ConfigurationExtensions *:
	superClassifiers +=ClassifierOrTypeReference
	("," superClassifiers +=ClassifierOrTypeReference)*;

fragment ImplementationExtensions *:
	superClassifiers +=ImplementationReference
	("," superClassifiers +=ImplementationReference)*;

fragment InterfaceExtensions *:
	superClassifiers +=ReversableInterfaceReference
	("," superClassifiers +=ReversableInterfaceReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' assignedClassifiers+=ClassifierOrTypeReference (',' assignedClassifiers+=ClassifierOrTypeReference)*
;

Workingset returns av3::Workingset: 
	(private?='private')? 'workingset' name=QualifiedName 'is' 
	UseProps?
	 ( instanceRoots+=InstanceConfiguration )*  
	'end' ';'
;

InstanceConfiguration returns av3::InstanceConfiguration:
	{av3::InstanceConfiguration} name=ID ':' category=ComponentCategory
	typeReferences+=ClassifierOrTypeReference 
	(actions+=STRING)*
	(productlineConstraint=ProductLineConstraint)?
	';'
;

ProductLineConstraint returns av3::ConditionOperation:
	{av3::ConditionOperation}
	'plc' element=PropertyReference operator=SatisfiesOperation constraint=ListLiteral
;

// Behavior specification including error behavior


BehaviorSpecification returns av3::BehaviorSpecification :
	'@' name=ID '{'
		BehaviorSpecificationBlock
	 '}'';'
;

fragment BehaviorSpecificationBlock*:
	BehaviorSpecificationElement*
;

fragment BehaviorSpecificationElement*:
	generators+= Event | rules+= TransitionRule| rules+= BFlowRule | stateVariables+= StateVariable
;


StateVariable returns av3::StateVariable:
	(annotations += Annotation )*
	name=ID ':' 'state' stateType=[av3::TypeDef|QualifiedName] 
	(initialState=EnumerationLiteral)?	';'
;


Event returns av3::Generator:
	name=ID ':' type=('error'|'recover'|'repair') 'event' 
	(value=ListLiteral)?	';'
;


TransitionRule returns av3::BehaviorRule :
	(annotations += Annotation )*
	name=ID ':' 'transition' currentState=CurrentState '->' targetState=TargetState 'when' condition =  (MultiLiteralOperation | ModelElementContainsLiteral | ModelElementReference) ';'
;

BFlowRule returns av3::BehaviorRule :
	(annotations += Annotation )*
	name=ID ':' 'flow'  (source?='source' |condition =(MultiLiteralOperation | ModelElementContainsLiteral | ModelElementReference)) '->'  (sink?='sink' | actions+=Assignment*) ('when' currentState=CurrentState )?';'
;

Assignment returns av3::Assignment:
	target= ModelElementReference ('(' value=NamedElementReference')')?
;

CurrentState returns av3::StateSpecification:
	stateVariable=[av3::StateVariable|ID] '=' currentState=EnumerationLiteral 
;

TargetState returns av3::StateSpecification:
	stateVariable=[av3::StateVariable|ID] '=' currentState=EnumerationLiteral 
;


ModelElementContainsLiteral returns av3::ConditionOperation:
	 element=ModelElementReference operator=InOperation constraint=ListLiteral
;

FeatureInput returns av3::ConditionOperation:
	 element=ModelElementReference operator=InputOperation 
;

// Annotations

Annotation returns av3::Annotation:
	'@' name=ID ('(' (value = Literal | (nameValuePairs+= NameValuePair)+) ')')?
;

NameValuePair returns av3::NameValuePair:
	name=ID '=' value = Literal
;

// expression/constraint language

Literal returns av3::Literal:
	IntegerLiteral | RealLiteral | StringLiteral | BooleanLiteral | PropertyReference  | DirectionalLiteral | ListLiteral | MultiLiteralOperation
	| ModelElementContainsLiteral   | NamedElementReference //| EnumerationLiteral //| FeatureInput
;


PackageElementReference returns av3::PackageElementReference :  
	 element=[av3::PackageElement|QualifiedName]
;

PropertyReference returns av3::PackageElementReference :  
	'#' element=[av3::PackageElement|QualifiedName]
;

IntegerLiteral returns av3::Literal:
	{av3::IntegerLiteral} value=INT unit=ID?
;

RealLiteral returns av3::Literal:
	{av3::RealLiteral} value=DOUBLE unit=ID?
;

terminal DOUBLE returns ecore::EDouble: ('0'..'9')+ '.' ('0'..'9')+;

StringLiteral returns av3::Literal:
	{av3::StringLiteral} value=NoQuoteString
;

EnumerationLiteral returns av3::EnumerationLiteral:
	{av3::EnumerationLiteral} name=ID
;

NoQuoteString :
	// remove quotes from string in ValueConverter
	STRING
;

BooleanLiteral returns av3::Literal:
	{av3::BooleanLiteral} (value?='true'|'false')
;

ListLiteral returns av3::ListLiteral:
	{av3::ListLiteral} '(' (elements+=Literal (',' elements+=Literal)*)? ')'
;

DirectionalLiteral returns av3::DirectionalLiteral:
	{av3::DirectionalLiteral}direction=PropagationDirection value=Literal
;


MultiLiteralOperation returns av3::MultiLiteralConstraint:
	{av3::MultiLiteralConstraint} operator=EOperation '(' (elements+=Literal (',' elements+=Literal)*)? ')'
;


QualifiedNameWithWildcard:
	QualifiedName '::*';

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('::' ID)*;

QualifiedTypesReference:
	QualifiedName ('.'ID)?;

QualifiedReference:
	QualifiedName;

QualifiedDottedReference:
	QualifiedName '.' ID;

ComponentCategory returns av3::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | 'parameter' | DataAccessKeywords 
	| BusAccessKeywords | VirtualBusAccessKeywords | SubprogramAccessKeywords | SubprogramGroupAccessKeywords
	| 'binding' | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;

PropagationDirection returns av3::FeatureDirection:
	'in' | 'out' ;

Composite returns av3::Composite:
	'list' | 'set' ;

Primitive returns av3::Primitive:
	'boolean' | 'integer' | 'real' | 'string' ;
	

EOperation returns av3::EOperator:
	'any' | 'all' | 'oneof' | 'of' | 'ormore' | 'orless' ;

COperation returns av3::COperator:
	'in' | 'contains' | 'equals'  | 'satisfies' | '?';

SatisfiesOperation returns av3::COperator:
	 'satisfies' ;

InOperation returns av3::COperator:
	 'in' ;

InputOperation returns av3::COperator:
	 '?' ;
	
AssociationType returns  av3::AssociationType:
	IsConnection | IsBinding | IsFlow 
;

IsConnection returns av3::AssociationType:
	'connection' ;

IsBinding returns av3::AssociationType:
	'binding' ;

IsFlowSource returns av3::AssociationType:
	FlowSourceKeywords ;

IsFlowSink returns av3::AssociationType:
	FlowSinkKeywords ;

IsFlow returns av3::AssociationType:
	'flow' ;


VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

FlowSourceKeywords: 'flow''source';
FlowSinkKeywords: 'flow''sink';
//FlowPathKeywords: 'flow';

InOutKeywords: 'in''out'; 
BusAccessKeywords: 'bus''access' ; 
VirtualBusAccessKeywords: 'virtual''bus''access' ; 
DataAccessKeywords: 'data''access' ; 
SubprogramAccessKeywords: 'subprogram''access' ; 
SubprogramGroupAccessKeywords: 'subprogram''group''access' ; 

ProvidesReadKeywords: 'provides' 'in';
RequiresReadKeywords: 'requires' 'in';
ProvidesWriteKeywords: 'provides' 'out';
RequiresWriteKeywords: 'requires' 'out';
ProvidesRWKeywords: 'provides' 'in''out';
RequiresRWKeywords: 'requires' 'in''out';

        
terminal ANNEXTEXT:
	'{*' -> '*}';
        