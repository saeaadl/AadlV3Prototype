// automatically generated by Xtext
grammar org.osate.xtext.aadlv3.AadlV3 with org.eclipse.xtext.common.Terminals

import "http://www.osate.org/aadlv3/Aadlv3" as av3
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


PackageDeclaration returns av3::PackageDeclaration:
	(private?='private')? 'package' name=QualifiedName 'is'
	(imports+=Import |
	elements+= PackageElement)*
	'end' ';';

PackageElement returns av3::PackageElement:
	PackageDeclaration | DataType | ComponentInterface | ComponentImplementation | ComponentConfiguration | PropertyDefinition | PropertySet | Workingset
;

PropertyDefinition returns av3::PropertyDefinition:
	(private?='private')? 'property' name=ID ':' type=[av3::Type|QualifiedReference] 
	('for' '(' ( forAll?='all' | (AppliesTo (',' AppliesTo)*)) ')'  )? 
	';' ;

fragment AppliesTo*:
	componentCategories+=ComponentCategory | featureCategories+=FeatureCategory 
		| associationTypes+=AssociationType 
	
;

PropertySet returns av3::PropertySet:
	(private?='private')? 'properties' name=ID  ':'
		'{' properties += [av3::PropertyDefinition|QualifiedReference] (',' properties += [av3::PropertyDefinition|QualifiedName])* '}'
	';'
;

DataType returns av3::DataType:
	(private?='private')? 'type' name=ID PropertiesBlock? ';';

ComponentInterface returns av3::ComponentInterface:
	(private?='private')? category=ComponentCategory? 'interface'  name=ID ('extends' InterfaceExtensions)? 
	 InterfaceBody ';'
	;

fragment InterfaceBody*:
	'is' (InterfaceElement )*  'end'
;
fragment InterfaceElement*:
	 features+=Feature 
	 | flows+=FlowPath |  flows+=FlowSource |  flows+=FlowSink  
	  | propertyAssociations+=PropertyAssociation | annexSubclause+=AnnexSubclause
;
	

ComponentImplementation returns av3::ComponentImplementation:
	(private?='private')? category=ComponentCategory name=DottedName 
	('extends' ImplementationExtensions)? 
	 ImplementationBody ';'
	  ;

fragment ImplementationBody*:
	'is' (ImplementationElement )* 	'end'
;

fragment ImplementationElement* :
	connections+=Connection |
	 bindings+=Binding | components+=Component 
		| paths+= Path | flowAssignments+=FlowAssignment | classifierAssignments+=ClassifierAssignment | classifierAssignments+=ClassifierAssignmentPattern
		| propertyAssociations+=PropertyAssociation | annexSubclause+=AnnexSubclause
;

ComponentConfiguration returns av3::ComponentConfiguration:
	(private?='private')? 'configuration' name=DottedName  
	Parameters?
	// optional extension. If no extends then we have a generic configuration with patterns
	('extends' ConfigurationExtensions)? ConfigurationElementBlock ';'
	 ;
	

// (Instance) model elements

Feature returns av3::Feature:
	name=ID ':' direction=FeatureDirection?  
	category=FeatureCategory 
	(typeReference=ReversableTypeReference )?
	(propagation=Propagations|propagation=EPropagations)?
	annexElements+=AnnexElement*
	PropertiesBlock? ';'
	;

Component returns av3::Component:
	name=ID ':' category=ComponentCategory
	(typeReferences+=TypeReference 
		//(',' typeReferences+=TypeReference?)*
	)?
	NestedComponentImplementationBlock? ';'
 ;

Connection returns av3::Association:
	name=ID ':' associationType=IsConnection source=ModelElementReference
	('->'|bidirectional?='<->') destination=ModelElementReference PropertiesBlock? ';';


Binding returns av3::Association:
	name=ID ':' bindingType=[av3::DataType|QualifiedName]? associationType=IsBinding 
	source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ';';


FlowPath returns av3::Association:
	name=ID ':' associationType=IsFlow source=ModelElementReference
	'->' destination=ModelElementReference PropertiesBlock? ';';

FlowSource returns av3::Association:
	name=ID ':' associationType=IsFlowSource  destination=ModelElementReference  PropertiesBlock? ';' ;

FlowSink returns av3::Association:
	name=ID ':' associationType=IsFlowSink  source=ModelElementReference 
	 PropertiesBlock? ';';

fragment UseProps*:	
	'use''properties' useProperties += [av3::PropertySet|QualifiedName] (',' useProperties += [av3::PropertySet|QualifiedName])* 
	';'
;


Propagations returns av3::TypeSet:	
	'propagates' direction=FeatureDirection? '{'   propagatedTypes+=[av3::Type|QualifiedTypesReference]
 (',' propagatedTypes+=[av3::Type|QualifiedTypesReference]
)* 
	'}'
;

EPropagations returns av3::TypeSet:	
	'@e' '{' direction=FeatureDirection? propagatedTypes+=[av3::Type|QualifiedTypesReference]
 (',' propagatedTypes+=[av3::Type|QualifiedTypesReference]
)* 
	'}'
;


Path returns av3::PathSequence:
	name=ID ':' 'flow' elements+=PathElement ('->' elements+=PathElement)+
	 PropertiesBlock? ';';


PathElement returns av3::PathElement:
	element=[av3::ModelElement|ID] => ({av3::PathElement.context=current} '.' element=[av3::ModelElement|ID])*;


Import returns av3::Import:
	'import' (importedNamespace=QualifiedNameWithWildcard | importedNamespace=QualifiedName)
	('as' alias=ID)?
	';';

ClassifierAssignment returns av3::ClassifierAssignment:
	target= ModelElementReference '=>' 
	((assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	';'
	;

ClassifierAssignmentPattern returns av3::ClassifierAssignmentPattern:
	QueryExpression '=>' 
	((assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)* (CurlyConfigurationElementBlock)?)
	| CurlyConfigurationElementBlock)
	';'
	;

fragment QueryExpression *: 
'all''('targetPattern = [av3::Type|QualifiedTypesReference] ')';

FlowAssignment returns av3::PathSequence:
	target= ModelElementReference '=>' 'flow'
	elements+=PathElement ('->' elements+=PathElement)*
	';'
	;


PropertyAssociation returns av3::PropertyAssociation:
	 ( target=ModelElementReference)? 
	 '#' property=[av3::PropertyDefinition|QualifiedName] 
	propertyAssociationType=PropertyAssociationType value=PropertyValue
	 ';'
	;

PropertyValue returns av3::PropertyValue:
	 value=INT unit=ID?
;

ModelElementReference returns av3::ModelElementReference:
	// => or -> both work
	element=[av3::ModelElement|ID] -> ({av3::ModelElementReference.context=current} '.' element=[av3::ModelElement|ID])*;


fragment ConfigurationElementBlock *:
	'is' (ConfigurationElement )* 'end';

fragment CurlyConfigurationElementBlock *:
	'{' (ConfigurationElement  )+ '}'; 

fragment ConfigurationElement*: 
	propertyAssociations+=PropertyAssociation | 
	bindings+=Binding | classifierAssignments+=ClassifierAssignment | classifierAssignments+=ClassifierAssignmentPattern | annexSubclause+=AnnexSubclause
;

fragment Parameters *:
	parameterized?='(' (parameters+=ConfigurationParameter (',' parameters+=ConfigurationParameter)*)? ')';

ConfigurationParameter returns av3::ConfigurationParameter:
	name=ID ':' type=[av3::Type|QualifiedName] ;


// reference objects for classifiers including configurations with parameter

ReversableInterfaceReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::ComponentInterface|QualifiedReference] ;

ReversableTypeReference returns av3::TypeReference:
	reverse?='reverse'? type=[av3::Type|QualifiedReference] ;

TypeReference returns av3::TypeReference :  
	 type=[av3::Type|QualifiedTypesReference]
	  ConfigurationActuals?
;

RealizationReference returns av3::TypeReference :  
	 type=[av3::ComponentRealization|QualifiedDottedReference]
	  ConfigurationActuals?
;

ImplementationReference returns av3::TypeReference :  
	 type=[av3::ComponentImplementation|QualifiedDottedReference]
;

AnnexSubclause returns av3::AnnexSubclause :
	'@' name=ID '{' '}'
;

AnnexElement returns av3::AnnexElement :
	'@' name=ID '{' '}'
;

fragment PropertiesBlock *:
	'{' (propertyAssociations+=PropertyAssociation )+ '}';

// to be used for inline nested component implementations 
fragment NestedComponentImplementationBlock *:
	 '{'  ( NestedImplementationElement )+ 
	 	'}';
	 	
fragment NestedImplementationElement*: 
	features+=Feature | connections+=Connection | bindings+=Binding | components+=Component |  propertyAssociations+=PropertyAssociation
;

fragment ConfigurationExtensions *:
	superClassifiers +=TypeReference
	("," superClassifiers +=TypeReference)*;

fragment ImplementationExtensions *:
	superClassifiers +=ImplementationReference
	("," superClassifiers +=ImplementationReference)*;

fragment InterfaceExtensions *:
	superClassifiers +=ReversableInterfaceReference
	("," superClassifiers +=ReversableInterfaceReference)*;


fragment ConfigurationActuals*:
	'(' (actuals+=ConfigurationActual (',' actuals+=ConfigurationActual)*)? ')'	
;

ConfigurationActual returns av3::ConfigurationActual:
	parameter=[av3::ConfigurationParameter|ID] '=>' assignedClassifiers+=TypeReference (',' assignedClassifiers+=TypeReference)*
;

Workingset returns av3::Workingset: 
	(private?='private')? 'workingset' name=QualifiedName 'is' 
	UseProps?
	 ( rootComponents+=Component )*  
	'end' ';'
;



QualifiedNameWithWildcard:
	QualifiedName '::*';

DottedName:
	ID '.' ID;

QualifiedName:
	ID ('::' ID)*;

QualifiedTypesReference:
	QualifiedName ('.'ID)?;

QualifiedReference:
	QualifiedName;

QualifiedDottedReference:
	QualifiedName '.' ID;


ComponentCategory returns av3::ComponentCategory: 'abstract' | 'bus'|'data'
	| 'device' | 'memory' | 'process' | 'processor' | 'system' 
	| 'thread' | VirtualBusKeywords | VirtualProcessorKeywords | VirtualMemoryKeywords | VirtualDeviceKeywords
	| 'subprogram' | SubprogramGroupKeywords | ThreadGroupKeywords ;

FeatureCategory returns av3::FeatureCategory:
	'feature' | 'port' | 'parameter' | DataAccessKeywords 
	| BusAccessKeywords | VirtualBusAccessKeywords | SubprogramAccessKeywords | SubprogramGroupAccessKeywords
	| 'binding' | 'interface';

FeatureDirection returns av3::FeatureDirection:
	'in' | 'out' 
	| InOutKeywords | 'requires' | 'provides'|
	ProvidesReadKeywords | RequiresReadKeywords | ProvidesWriteKeywords | RequiresWriteKeywords | ProvidesRWKeywords | RequiresRWKeywords
	;

PropagationDirection returns av3::FeatureDirection:
	'in' | 'out' ;
	
	
AssociationType returns  av3::AssociationType:
	IsConnection | IsBinding | IsFlow 
;

IsConnection returns av3::AssociationType:
	'connection' ;

IsBinding returns av3::AssociationType:
	'binding' ;

IsFlowSource returns av3::AssociationType:
	FlowSourceKeywords ;

IsFlowSink returns av3::AssociationType:
	FlowSinkKeywords ;

IsFlow returns av3::AssociationType:
	'flow' ;


PropertyAssociationType returns av3::PropertyAssociationType:
	'=>' | '=' | '*=>' 
;

VirtualProcessorKeywords:
	'virtual' 'processor'
;

VirtualBusKeywords:
	'virtual' 'bus'
;

VirtualMemoryKeywords:
	'virtual' 'memory'
;

VirtualDeviceKeywords:
	'virtual' 'device'
;

ThreadGroupKeywords:
	'thread' 'group'
;

SubprogramGroupKeywords:
	'subprogram' 'group'
;

FlowSourceKeywords: 'flow''source';
FlowSinkKeywords: 'flow''sink';
//FlowPathKeywords: 'flow';

InOutKeywords: 'in''out'; 
BusAccessKeywords: 'bus''access' ; 
VirtualBusAccessKeywords: 'virtual''bus''access' ; 
DataAccessKeywords: 'data''access' ; 
SubprogramAccessKeywords: 'subprogram''access' ; 
SubprogramGroupAccessKeywords: 'subprogram''group''access' ; 

ProvidesReadKeywords: 'provides' 'in';
RequiresReadKeywords: 'requires' 'in';
ProvidesWriteKeywords: 'provides' 'out';
RequiresWriteKeywords: 'requires' 'out';
ProvidesRWKeywords: 'provides' 'in''out';
RequiresRWKeywords: 'requires' 'in''out';
        
