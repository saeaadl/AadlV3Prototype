/*
 * generated by Xtext 2.14.0
 */
package org.osate.xtext.aadlv3.validation

import com.google.common.collect.SetMultimap
import org.eclipse.xtext.validation.Check
import org.osate.aadlv3.aadlv3.Aadlv3Package
import org.osate.aadlv3.aadlv3.Association
import org.osate.aadlv3.aadlv3.Component
import org.osate.aadlv3.aadlv3.ComponentCategory
import org.osate.aadlv3.aadlv3.ComponentClassifier
import org.osate.aadlv3.aadlv3.ComponentConfiguration
import org.osate.aadlv3.aadlv3.ComponentImplementation
import org.osate.aadlv3.aadlv3.ComponentInterface
import org.osate.aadlv3.aadlv3.ComponentRealization
import org.osate.aadlv3.aadlv3.ConfigurationActual
import org.osate.aadlv3.aadlv3.ConfigurationAssignment
import org.osate.aadlv3.aadlv3.ConfigurationParameter
import org.osate.aadlv3.aadlv3.DataType
import org.osate.aadlv3.aadlv3.Feature
import org.osate.aadlv3.aadlv3.FeatureCategory
import org.osate.aadlv3.aadlv3.FeatureDirection
import org.osate.aadlv3.aadlv3.ModelElement
import org.osate.aadlv3.aadlv3.PathElement
import org.osate.aadlv3.aadlv3.PathSequence
import org.osate.aadlv3.aadlv3.PropertyAssociation
import org.osate.aadlv3.aadlv3.TypeReference

import static org.osate.aadlv3.util.Av3API.*

import static extension org.osate.aadlv3.util.Aadlv3Util.*
import org.osate.aadlv3.aadlv3.PropertyAssociationType
import java.util.Collections
import java.util.Stack
import org.osate.aadlv3.aadlv3.NamedElement
import org.osate.aadlv3.aadlv3.PropertyDefinition
import org.eclipse.emf.ecore.EObject

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AadlV3Validator extends AbstractAadlV3Validator {

	public static val DUPLICATE_NAMES = 'DuplicateNames'
	public static val ONLY_SUPER_INTERFACES = 'OnlySuperInterfaces'
	public static val NO_SUPER_INTERFACES = 'NoSuperInterfaces'
	public static val NO_SUPER_CONFIGURATIONS = 'NoSuperConfigurations'
	public static val BAD_BINDING_POINT_DIRECTION = 'BadBindingPointDirection'
	public static val BAD_BUS_ACCESS_DIRECTION = 'BadBusAccessDirection'
	public static val BAD_VIRTUAL_BUS_ACCESS_DIRECTION = 'BadVirtualBusAccessDirection'
	public static val BAD_SUBPROGRAM_ACCESS_DIRECTION = 'BadSubprogramAccessDirection'
	public static val BAD_SUBPROGRAM_GROUP_ACCESS_DIRECTION = 'BadSubprogramGroupAccessDirection'
	public static val BAD_DATA_ACCESS_DIRECTION = 'BadDataAccessDirection'
	public static val BAD_PORT_DIRECTION = 'BadPortDirection'
	public static val BAD_FEATURE_DIRECTION = 'BadFeatureDirection'
	public static val BAD_INTERFACE_DIRECTION = 'BadInterfaceDirection'
	public static val ONLY_INTERFACES_REVERSE = 'OnlyInterfacesReverse'
	public static val MISMATCHED_COMPONENT_CATEGORY = 'MismatchedCategory'
	public static val IN_TO_OUT = 'InToOut'
	public static val OUT_TO_IN = 'OutToIn'
	public static val SAME_DIRECTION = 'SameDirection'
	public static val REQUIRES_TO_PROVIDES = 'RequiresToProvides'
	public static val MUST_BE_OUT = 'MustBeOut'
	public static val MUST_BE_IN = 'MustBeIn'
	public static val MUST_BE_BI = 'MustBeBidirectional'
	public static val MATCH_FEATURE_CATEGORY = 'MatchFeatureCategory'
	public static val MUST_BE_BINDING_POINT = 'MustBeBindingPoint'
	public static val NO_BINDING_POINT = 'NoBindingPoint'
	public static val BetweenSubcomponents = 'BetweenSubcomponents'
	public static val ToSubcomponents = 'ToSubcomponents'
	public static val FeatureAndSubcomponent = 'FeatureAndSubcomponent'
	public static val NotSubcomponentFeature = 'NotSubcomponentFeature'
	public static val BetweenFeatures = 'BetweenFeatures'
	public static val MatchingTypes = 'MatchingTypes'
	public static val ToFlowSpec = 'ToFlowSpec'
	public static val MissingOneType = 'MissingOneType'
	public static val OnlyPropertyAssociations = 'OnlyPropertyAssociations'
	public static val MustBeDataType = 'MustBeDataType'
	public static val NoDataType = 'NoDataType'
	public static val FormalActualMismatch = 'FormalActualMismatch'
	public static val ConfigurationPattern = 'ConfigurationPattern'
	public static val ParameterNotInterface = 'ParameterNotInterface'
	public static val OverrideType = 'OverrideType'
	public static val OneType = 'OneType'
	public static val DifferentComponentInPath = 'DifferentComponentInPath'
	public static val NoInterface = 'NoComponentInterface'
	public static val DoesNotApply = 'DoesNotApply'
	public static val NoOverride = 'NoOverride'
	public static val NoDoubleAssignment = 'NoDoubleAssignment'
	public static val NoFinalChange = 'NoFinalChange'
	public static val ConflictingFinal = 'ConflictingFinal'
	public static val MustBeFinal = 'MustBeFinal'
	public static val NoCommonImplementation = 'NoCommonImplementation'
	

	@Check
	def checkComponentClassifier(ComponentClassifier cl) {
		cl.checkConsistentCategory()
		cl.checkCommonTopComponentImplementation
		cl.checkDuplicatePropertyAssociations
		cl.checkCompositePropertyAssociationTypeConsistency
	}

	@Check
	def checkComponentInterface(ComponentInterface cif) {
		cif.checkUniqueModelElementNames()
		cif.checkComponentInterfaceExtensions()
	}

	@Check
	def checkComponentImplementation(ComponentImplementation cimpl) {
		cimpl.checkInterface()
		cimpl.checkUniqueModelElementNames()
		cimpl.checkComponentImplementationExtensions()
	}

	@Check
	def checkComponentConfiguration(ComponentConfiguration config) {
		config.checkInterface()
		config.checkConsistentTopImplementation
	}

	@Check
	def checkFeature(Feature fea) {
		fea.checkFeatureDirection()
		if (fea.category != FeatureCategory.INTERFACE && fea?.typeReference?.isReverse) {
			error('Only interface features can reverse direction', fea, Aadlv3Package.Literals.FEATURE__TYPE_REFERENCE,
				ONLY_INTERFACES_REVERSE)
		}
	}

	@Check
	def checkAssociation(Association assoc) {
		assoc.checkConsistentDirection
		assoc.checkConsistentFeatureCategory
		assoc.checkConsistentTargets
		assoc.checkMatchingTypes
	}

	@Check
	def checkConfigurationAssignment(ConfigurationAssignment ca) {
		ca.checkConfigurationAssignmentCategory
		ca.checkCommonTopComponentImplementation
		ca.checkDuplicatePropertyAssociations
		ca.checkCompositePropertyAssociationTypeConsistency
	}

	@Check
	def checkPathSequence(PathSequence flowa) {
		// flow assignment or end to end path
		if (flowa.name === null || flowa.name.empty) {
			// flow assignment
			if (!(flowa.target.element instanceof Association && (flowa.target.element as Association).isFlowSpec)) {
				error('Flow assignment must be for flow specification', flowa,
					Aadlv3Package.Literals.PATH_SEQUENCE__TARGET, ToFlowSpec)
			}
		// the first and last path element may be feature mappings
		}
		// for both the sequence has to be consistent
		flowa.checkPathSequenceConsistency
	}

	@Check
	def checkPathElement(PathElement pe) {
		if (!(pe.element instanceof Association &&
			((pe.element as Association).isFlowSpec || (pe.element as Association).isConnection ||
				(pe.element as Association).isFeatureDelegate) || pe.element instanceof Component)) {
			error('path element must reference a connection, flow spec, or component', pe, null, ToFlowSpec)
		}
	}

	@Check
	def checkComponent(Component comp) {
		comp.checkConsistentCategory
		comp.checkCommonTopComponentImplementation
		comp.checkDuplicatePropertyAssociations
	}

	@Check
	def checkConfigurationParameter(ConfigurationParameter param) {
		if (!(param.type instanceof ComponentInterface)) {
			error('Configuration parameter type is not a component interface', param,
				Aadlv3Package.Literals.CONFIGURATION_PARAMETER__TYPE, ParameterNotInterface)
		}
	}

	@Check
	def checkConfigurationActual(ConfigurationActual ca) {
		val cif = ca.parameter.type
		if (cif instanceof ComponentClassifier) {
			val assignedtypes = ca.assignedClassifiers
			for (assignedtyperef : assignedtypes) {
				val assignedtype = assignedtyperef.type
				if (assignedtype instanceof ComponentClassifier) {
					if (!(cif.isSuperClassifierOf(assignedtype))) {
						error('Configuration actual does not match component classifier of configuration parameter', ca,
							null, FormalActualMismatch)
					}
				} else if (assignedtype instanceof DataType) {
						error('Configuration actual (data type) does not match component classifier of configuration parameter', ca,
							null, FormalActualMismatch)
				} else if (assignedtype instanceof ConfigurationParameter) {
					val assignedcif = assignedtype.type
					if (assignedcif instanceof ComponentClassifier) {
						if (!(cif.isSuperClassifierOf(assignedcif))) {
							error(
								'Configuration actual is not an extension of component classifier of referenced configuration parameter',
								ca, null, FormalActualMismatch)
						}
					}
				} else {
					// should be an assigned component classifier
					error('Configuration actual is not a component classifier', ca, null, FormalActualMismatch)
				}
			}
		} else if (cif instanceof DataType){
			val assignedtypes = ca.assignedClassifiers
			for (assignedtyperef : assignedtypes) {
				val assignedtype = assignedtyperef.type
				if (assignedtype instanceof ComponentClassifier) {
						error('Configuration actual (component classifier) does not match configuration parameter data type', ca,
							null, FormalActualMismatch)
				} else if (assignedtype instanceof DataType) {
					if (!(cif.isSuperDataTypeOf(assignedtype))) {
						error('Configuration actual (data type) is not an extension of configuration parameter data type', ca,
							null, FormalActualMismatch)
					}
				} else if (assignedtype instanceof ConfigurationParameter) {
					val assignedcif = assignedtype.type
					if (assignedcif instanceof ComponentClassifier) {
							error(
								'Configuration actual (component classifier) does not match referenced configuration parameter data type',
								ca, null, FormalActualMismatch)
					}
				} else {
					// should be an assigned component classifier
					error('Configuration actual is not a component classifier', ca, null, FormalActualMismatch)
				}
			}
		}
	}



	@Check
	def checkPropertyAssociation(PropertyAssociation pa) {
		pa.checkPropertyAssociationAppliesto
		pa.checkLocalPropertyAssociationType
		pa.checkPropertyAssociationFinal
	}
	
	def checkPropertyAssociationAppliesto(PropertyAssociation pa) {
		if (pa.target !== null){
			val targetme = pa.target.element
			switch (targetme) {
				Component: {
					if (!pa.property.appliesToCategory(targetme.category)) {
					val allowedUse = targetme.typeReferences.allowedUseProperties
						if (allowedUse.empty) {
							error('Property does not apply to ' + targetme.category, pa,
								Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
						} else {
							if (!allowedUse.exists[pd|sameProperty(pd, pa.property)]) {
								error('Property does not apply to subcomponent ' + targetme.name, pa,
									Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
							}
						}
					}
				}
				Feature: {
					if (!pa.property.appliesToCategory(targetme.category)) {
						error('Property does not apply to '+targetme.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Association: {
					if (!pa.property.appliesToCategory(targetme.associationType)) {
						error('Property does not apply to '+targetme.associationType, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
			}
		} else {
			// associated with containing element
			val paTarget = pa.eContainer
			switch (paTarget){
				Component: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to '+paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				ComponentClassifier: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to '+paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Feature: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to '+paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Association: {
					if (!pa.property.appliesToCategory(paTarget.associationType)) {
						error('Property does not apply to '+paTarget.associationType, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
			}
		}
	}
	
	def checkPropertyAssociationFinal(PropertyAssociation pa) {
		if (pa.eContainer instanceof ConfigurationAssignment){
			if (pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE){
				error('Property assignment in configuration assignment must be \':=\'', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
			if (pa.target.element.hasLocalFinalPropertyAssociationLocalFinal(pa.property)){
				error('Locally assigned property value is already \':=\'', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		} else if (pa.eContainer instanceof ComponentConfiguration){
			if (pa.propertyAssociationType === PropertyAssociationType.VARIABLE_VALUE){//&& !(pa.eContainer as ComponentConfiguration).superClassifiers.empty){
				error('Property assignment in configuration must be \':=\'', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
//			if (pa.propertyAssociationType !== PropertyAssociationType.DEFAULT_VALUE && (pa.eContainer as ComponentConfiguration).superClassifiers.empty){
//				error('Property assignment in reusable configuration must be \'*=>\'', pa,
//					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
//			}
			if (pa.target.element.hasLocalFinalPropertyAssociationLocalFinal(pa.property)){
				error('Locally assigned property value is already \':=\'', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		} else if (pa.target !== null && pa.target.modelElementReferenceReachDown){
			if (pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE && !(pa.eContainer as ComponentConfiguration).superClassifiers.empty){
				error('Reach down property assignment must be \':=\'', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
			if (pa.target.element.hasLocalFinalPropertyAssociationLocalFinal(pa.property)){
				error('Locally assigned property value is already \':=\'', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		}
	}
	
		
	def hasLocalFinalPropertyAssociationLocalFinal(ModelElement ne, PropertyDefinition pd) {
		if (ne instanceof Component){
			val pas = ne.typeReferences.allPropertyAssociations+ne.propertyAssociations
			pas.exists[pa|sameProperty(pa.property, pd)&& pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE && pa.target === null]
		} else {
			ne.propertyAssociations.exists[pa|sameProperty(pa.property, pd)&& pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE&& pa.target === null]
		}
		return false
	}
	

	/**
	 * check property association 
	 */
	def checkLocalPropertyAssociationType(PropertyAssociation pa) {
		if (pa.target !== null){
			val targetme = pa.target.element
			if (targetme instanceof Component) {
				// for all property assignments to components, if the component classifier already has a local assignment that is final
				val tpas = targetme.typeReferences.allPropertyAssociations
				for (tpa : tpas) {
					if (tpa.target === null && sameProperty(tpa.property, pa.property) &&
						tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
						error('Property association cannot change previously assigned final value', pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
					}
				}
			}
			// local target model element also has {} property assignment 
			val tpas = targetme.propertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && sameProperty(tpa.property, pa.property)) {
					error('Cannot assign property value twice in classifier context', pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, NoDoubleAssignment)
				}
			}
		} else {
			// associated with containing element. target is null
			val paTarget = pa.eContainer
			switch (paTarget){
				Component: {
					val tpas = paTarget.typeReferences.allPropertyAssociations + paTarget.propertyAssociations // PA in classifier and {} of feature
					for (tpa : tpas) {
						if (tpa.target === null && sameProperty(tpa.property, pa.property) &&
							tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
							error('Property association cannot change previously assigned final value', pa,
								Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
						}
					}
				}
				ComponentClassifier: {
					// check extends override
					val supercls = paTarget.allSuperComponentClassifiers
					for (supercl : supercls) {
						val spas = supercl.propertyAssociations
						for (spa : spas) {
							if (spa.target === null && sameProperty(spa.property, pa.property) &&
								spa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
								error('Property association cannot change previously assigned final value', pa,
									Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE,
									NoFinalChange)
							}
						}
					}
				}
				Feature: {
					val tpas = paTarget.propertyAssociations  // PA in {} of feature
					for (tpa : tpas) {
						if (tpa.target === null && sameProperty(tpa.property, pa.property) &&
							tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
							error('Property association cannot change previously assigned final value', pa,
								Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
						}
					}
				}
				Association: {
					val tpas = paTarget.propertyAssociations // PA in {} of feature
					for (tpa : tpas) {
						if (tpa.target === null && sameProperty(tpa.property, pa.property) &&
							tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
							error('Property association cannot change previously assigned final value', pa,
								Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
						}
					}
				}
			}
		}
	}

	def checkDuplicatePropertyAssociations(ComponentClassifier cl) {
		val pas = cl.propertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && sameProperty(first.property,second.property) && first.target?.targetPath == second.target?.targetPath) {
			error('Duplicate property association ' + first.property.name, cl,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, secondidx, NoDoubleAssignment)
			error('Duplicate property association ' + second.property.name, cl,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, firstidx, NoDoubleAssignment)
				}
			}
		}
	}

	def checkDuplicatePropertyAssociations(ConfigurationAssignment ca) {
		val pas = ca.propertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && sameProperty(first.property,second.property) && first.target?.targetPath == second.target?.targetPath) {
			error('Duplicate property association ' + first.property.name, ca,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, secondidx, NoDoubleAssignment)
			error('Duplicate property association ' + second.property.name, ca,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, firstidx, NoDoubleAssignment)
				}
			}
		}
	}

	def checkDuplicatePropertyAssociations(Component comp) {
		val pas = comp.propertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && sameProperty(first.property,second.property) && first.target?.targetPath == second.target?.targetPath) {
			error('Duplicate property association ' + first.property.name, comp,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, secondidx, NoDoubleAssignment)
			error('Duplicate property association ' + second.property.name, comp,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, firstidx, NoDoubleAssignment)
				}
			}
		}
	}
	
	def checkCompositePropertyAssociationTypeConsistency(ComponentClassifier cl){
		val pas= cl.superClassifiers.allPropertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && sameProperty(first.property,second.property) && first.target?.targetPath == second.target?.targetPath
					&& first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE&& second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE
				) {
			error('Conflicting \':=\' property association ' + first.target.targetPath+'#'+first.property.name, cl,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, cl.superClassifiers.indexOf(first.eContainer), ConflictingFinal)
			error('Conflicting \':=\' property association ' + second.target.targetPath+'#'+second.property.name, cl,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS, cl.superClassifiers.indexOf(second.eContainer), ConflictingFinal)
				}
			}
		}
	}
	
	def checkCompositePropertyAssociationTypeConsistency(ConfigurationAssignment ca){
		val pas= ca.assignedClassifiers.allPropertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && sameProperty(first.property,second.property) && first.target?.targetPath == second.target?.targetPath
					&& first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE&& second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE
				) {
			error('Conflicting \':=\' property association ' + first.target.targetPath+'#'+first.property.name, ca,
				Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS, ca.assignedClassifiers.getIndex(first.eContainer), ConflictingFinal)
			error('Conflicting \':=\' property association ' + second.target.targetPath+'#'+second.property.name, ca,
				Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS, ca.assignedClassifiers.getIndex(second.eContainer), ConflictingFinal)
				}
			}
		}
	}
	
	def int getIndex(Iterable<TypeReference> trs, EObject cl){
		var cnt = 0
		for (tr : trs) {
			if (tr.type === cl) return cnt
			cnt++
		}
		return -1
	}

		
	def void checkCompositeConfigurationAssignmentFinalPropertyAssociationConsistency(ComponentConfiguration cl){
		val SetMultimap <String, TypeReference> map = cl.cacheClassifierAssignments
		val keys = map.keySet
		for ( key : keys){
			val trs = map.get(key)
			trs.consistentTopComponentImplementation
		}
	}
	


	def checkUniqueModelElementNames(ComponentInterface cl) {
		val mels = cl.allModelElements.toList
		val max = mels.length
		for (var firstidx = 0; firstidx < max - 1; firstidx++) {
			val first = mels.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < max; secondidx++) {
				val second = mels.get(secondidx)
				if (first !== second && first.name == second.name) {
					reportDuplicateNames(first, cl)
					reportDuplicateNames(second, cl)
				}
			}
		}
	}

	def checkInterface(ComponentRealization cimpl) {
		val interface = getComponentInterface(cimpl);
		if (interface === null) {
			error('Could not find Component Interface', cimpl, null, FormalActualMismatch)
		}
	}

	def checkPattern(ComponentConfiguration config) {
		if (config.superClassifiers.empty) {
			if (!config.configurationAssignments.empty&& !config.bindings.empty)
			error('Configurations without extend must only contain configuration assignment patterns', config, Aadlv3Package.Literals.COMPONENT_CONFIGURATION__CONFIGURATION_ASSIGNMENTS, ConfigurationPattern)
		}
	}

	def checkUniqueModelElementNames(ComponentImplementation cl) {
		val mels = cl.allModelElements.toList
		val maxmels = mels.length
		for (var firstidx = 0; firstidx < maxmels - 1; firstidx++) {
			val first = mels.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxmels; secondidx++) {
				val second = mels.get(secondidx)
				if (first !== second && first.name == second.name) {
					// do not report same name of model elements inherited from interface
					if (first.containingComponentClassifier === cl || second.containingComponentClassifier === cl){
						reportDuplicateNames(first, cl)
						reportDuplicateNames(second, cl)
					}
				}
			}
		}
	}

	def void reportDuplicateNames(ModelElement first, ComponentClassifier cl) {
		val firstcl = first.containingComponentClassifier
		if (firstcl == cl) {
			error('Duplicate model element with name ' + first.name, first, Aadlv3Package.Literals.NAMED_ELEMENT__NAME,
				DUPLICATE_NAMES)
		} else {
			var idx = 0;
			for (sclref : cl.superClassifiers) {
				val scl = sclref.type as ComponentClassifier
				if (firstcl.isSuperClassifierOf(scl)) {
					idx = cl.superClassifiers.indexOf(sclref)
				}
			}
			error('Duplicate model element with name ' + first.name, cl,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, idx, DUPLICATE_NAMES)
		}
	}

	def checkComponentInterfaceExtensions(ComponentInterface cif) {
		if (!cif.superClassifiers.forall[scif|scif.type instanceof ComponentInterface]) {
			error('Interface extensions must be interfaces', cif,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, ONLY_SUPER_INTERFACES)
		}
	}

	def checkComponentImplementationExtensions(ComponentImplementation cim) {
		val allcl = cim.superClassifiers
		if (allcl.exists[scil|scil.type instanceof ComponentInterface]) {
			error('Implementations cannot extend interfaces', cim,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, NO_SUPER_INTERFACES)
		}
		if (allcl.exists[scil|scil.type instanceof ComponentConfiguration]) {
			error('Implementations cannot extend configurations', cim,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, NO_SUPER_CONFIGURATIONS)
		}
	}
	
		/**
	 * Checks that the top implementations are not parallel super branches
	 */
	def void checkCommonTopComponentImplementation(ComponentClassifier cl){
		var ComponentImplementation top = null
		val trs = cl.superClassifiers
		for (tr : trs){
			if (tr.type instanceof ComponentClassifier){
				val topimpl = (tr.type as ComponentClassifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)){
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)){
					error('Implementation is conflict with implementation '+top.name, cl,
						Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, trs.indexOf(tr),NoCommonImplementation)
				}
			}
		}
	}

		/**
	 * Checks that the top implementations are not parallel super branches
	 */
	def void checkCommonTopComponentImplementation(Component sub){
		var ComponentImplementation top = null
		val trs = sub.typeReferences
		for (tr : trs){
			if (tr.type instanceof ComponentClassifier){
				val topimpl = (tr.type as ComponentClassifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)){
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)){
					error('Implementation is parallel to top implementation '+top.name, sub,
						Aadlv3Package.Literals.COMPONENT__TYPE_REFERENCES, trs.indexOf(tr),NoCommonImplementation)
				}
			}
		}
	}
	
	def void checkConsistentCategory(Component comp){
		for (tr : comp.typeReferences) {
			val t = tr.type
			if (t instanceof ComponentClassifier) {
				// the categories must be consistent
				val clcat = (tr.type as ComponentClassifier).componentCategory
				if (!(clcat === comp.category || clcat === ComponentCategory.INTERFACE)) {
					error('Component category conflicts with classifier category', comp,
						Aadlv3Package.Literals.COMPONENT__CATEGORY, MISMATCHED_COMPONENT_CATEGORY)
				}
				// data component cannot have classifier, only primitive type
				if (comp.category === ComponentCategory.DATA) {
					error('Data component must have data type', comp, Aadlv3Package.Literals.COMPONENT__CATEGORY,
						MustBeDataType)
				}
			} else if (t instanceof DataType) {
				if (!(comp.category === ComponentCategory.DATA || comp.category === ComponentCategory.INTERFACE)) {
					error('Components other than "data" or "component" cannot have primitive type', comp,
						Aadlv3Package.Literals.COMPONENT__CATEGORY, NoDataType)
				}
			} else {
				// configuration parameter
			}
		}
		// if has type references that are not data type then {} can only contain property associations
		if (!comp.typeReferences.empty && ! comp.typeReferences.isDataType && (!comp.features.empty || !comp.connections.empty || !comp.components.empty)) {
			error('Component with classifier can only have property associations in {}', comp, null,
				OnlyPropertyAssociations)
		}
		
	}

	
	def void checkConsistentTopImplementation(ComponentConfiguration cl){
		val SetMultimap <String, TypeReference> map = cl.cacheClassifierAssignments
		val keys = map.keySet
		for ( key : keys){
			val trs = map.get(key)
			trs.consistentTopComponentImplementation
		}
	}
		
	
	/**
	 * returns implementation that is the extension of all other implementations
	 */
	 def void consistentTopComponentImplementation(Iterable<TypeReference> trs){
		var ComponentImplementation top = null
		var TypeReference toptr = null
		for (tr : trs){
			if (tr.type instanceof ComponentClassifier){
				val cl = (tr.type as ComponentClassifier).getTopComponentImplementation
				if (cl !== null) {
					if (top === null || top.isSuperImplementationOf(cl)) {
						top = cl
						toptr = tr
					} else if (!cl.isSuperImplementationOf(top)) {
						val ca = tr.containingConfigurationAssignment
						if (ca !== null){
							val cc = ca.containingComponentConfiguration
							val idx = cc.configurationAssignments.indexOf(ca)
							val topca = toptr.containingConfigurationAssignment
							val topsub = toptr.containingSubcomponent
							val topcc = if (topca !== null) topca.containingComponentClassifier else topsub?.containingComponentClassifier
							error('Assigned implementation is in conflict with '+top.name +' assigned in classifier '+topcc?.name, cc,
							Aadlv3Package.Literals.COMPONENT_CONFIGURATION__CONFIGURATION_ASSIGNMENTS, idx,NoCommonImplementation)
						}
					}
				}
			}
		}
		return 
	}


	def checkFeatureDirection(Feature fea) {
		switch (fea.category) {
			case FeatureCategory.BINDINGPOINT: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES)) {
					error('Binding point direction must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_BINDING_POINT_DIRECTION)
				}
			}
			case BUSACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN ||
					fea.direction == FeatureDirection.REQUIRESIN || fea.direction == FeatureDirection.PROVIDESOUT ||
					fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES
				)) {
					error('Bus access direction must be provides or requires and in or out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_BUS_ACCESS_DIRECTION)
				}
			}
			case DATAACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN ||
					fea.direction == FeatureDirection.REQUIRESIN || fea.direction == FeatureDirection.PROVIDESOUT ||
					fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDESINOUT || fea.direction == FeatureDirection.REQUIRESINOUT
				)) {
					error('Data access direction must be provides or requires and in, out, or in out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_DATA_ACCESS_DIRECTION)
				}
			}
			case FEATURE: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.NONE)) {
					error('Feature direction must be in, out, or no direction', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case INTERFACE: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.NONE)) {
					error('Interface direction must be in, out, or no direction', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case PORT: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.INOUT)) {
					error('Port direction must be in, out, or in out', fea, Aadlv3Package.Literals.FEATURE__DIRECTION,
						BAD_FEATURE_DIRECTION)
				}
			}
			case SUBPROGRAMACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES	)) {
					error('Subprogram access must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_SUBPROGRAM_ACCESS_DIRECTION)
				}
			}
			case SUBPROGRAMGROUPACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES	)) {
					error('Subprogram group access must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_SUBPROGRAM_GROUP_ACCESS_DIRECTION)
				}
			}
			case VIRTUALBUSACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN ||
					fea.direction == FeatureDirection.REQUIRESIN || fea.direction == FeatureDirection.PROVIDESOUT ||
					fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDESINOUT || fea.direction == FeatureDirection.REQUIRESINOUT
				)) {
					error('Virtual bus access direction must be provides or requires and in or out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_VIRTUAL_BUS_ACCESS_DIRECTION)
				}
			}
		}
	}

	def checkConsistentCategory(ComponentClassifier cl) {
		val cls = cl.allComponentClassifiers
		val targetcat = cl.componentCategory
		for (matchcl : cls) {
			if (matchcl !== cl) {
				val matchcat = matchcl.componentCategory
				if (matchcat !== targetcat && matchcat !== ComponentCategory.INTERFACE && targetcat!== ComponentCategory.INTERFACE) {
					error('Extension category differs', matchcl,
						Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS,
						AadlV3Validator.MISMATCHED_COMPONENT_CATEGORY)
				}
			}
		}
	}
	
	def checkConfigurationAssignmentCategory(ConfigurationAssignment ca) {
		if (ca.target.element instanceof Component) {
			val comp = ca.target.element as Component
			for (tr : ca.assignedClassifiers) {
				val assignedtype = tr.type
				val thetype = if(assignedtype instanceof ConfigurationParameter) assignedtype.type else assignedtype
				if (thetype instanceof ComponentClassifier) {
					val clcat = thetype.componentCategory
					if (!(comp.category === clcat || clcat === ComponentCategory.INTERFACE)) {
						error(
							'Category \'' + clcat + '\' of assigned classifier must be the same as the category \'' +
								comp.category + '\' of the component or must be "abstract"', ca, null,
							MISMATCHED_COMPONENT_CATEGORY)
					}
				} else if (thetype instanceof DataType) {
					// primitive type
					if (comp.category === ComponentCategory.DATA || comp.category === ComponentCategory.INTERFACE) {
						if (!comp.typeReferences.empty) {
							error('Assigned primitive type cannot override existing type', ca, null, OverrideType)
						}
					} else {
						error('Configuration assignment expects component classifier', ca, null, NoDataType)
					}
				}
			}
		} else if (ca.target.element instanceof Feature){
			val fea = ca.target.element as Feature
			if (ca.assignedClassifiers.size > 1){
				error('Can only assign one type to feature', ca, null, OneType)
			}
			for (tr : ca.assignedClassifiers) {
				val assignedtype = tr.type
				val thetype = if(assignedtype instanceof ConfigurationParameter) assignedtype.type else assignedtype
				if (thetype instanceof ComponentClassifier) {
					val clcat = thetype.componentCategory
					if (!(categoriesMatch(clcat,fea.category)
						|| (fea.category === FeatureCategory.INTERFACE &&clcat === ComponentCategory.INTERFACE))) {
						error(
							'Category \'' + clcat + '\' of assigned classifier must be the same as the category \'' +
								fea.category + '\' of the feature', ca, null,
							MISMATCHED_COMPONENT_CATEGORY)
					}
					if (!(fea.category === FeatureCategory.INTERFACE &&clcat === ComponentCategory.INTERFACE) && tr.isReverse){
						error(
							'Only named interfaces can be \'reverse\'', ca, Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
							ONLY_INTERFACES_REVERSE)
					}
				} else if (thetype instanceof DataType) {
					// data type
					if (fea.category === FeatureCategory.DATAACCESS || 
						fea.category === FeatureCategory.PORT ||
						fea.category === FeatureCategory.FEATURE ) {
						if (fea.typeReference !== null) {
							error('Assigned primitive type cannot override existing type', ca, null, OverrideType)
						}
					} else {
						error('Configuration assignment expects component classifier', ca, null, NoDataType)
					}
				}
			}
		} else {
			error('Configuration assignment must be for subcomponent or feature', ca,
				Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__TARGET, FeatureAndSubcomponent)
		}
	}
	
			/**
	 * Checks that the top implementations are not parallel super branches
	 */
	def void checkCommonTopComponentImplementation(ConfigurationAssignment ca){
		var ComponentImplementation top = null
		val trs = ca.assignedClassifiers
		for (tr : trs){
			if (tr.type instanceof ComponentClassifier){
				val topimpl = (tr.type as ComponentClassifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)){
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)){
					error('Implementation is in conflict with implementation '+top.name, ca,
						Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS, trs.indexOf(tr),NoCommonImplementation)
				}
			}
		}
	}
	
	

	def checkConsistentDirection(Association assoc) {
		if (assoc.source === null || assoc.destination === null) return
		val srcdir = assoc.source.realFeatureDirection
		val dstdir = assoc.destination.realFeatureDirection
		if (assoc.associationType.isConnection) {
			if (!assoc.isBidirectional){
				if (!(srcdir?.outgoing && dstdir?.incoming)) {
					error('Connection source must be outgoing and destination must be incoming', assoc, null, OUT_TO_IN)
				}
			} else {
				// bidirectional
				if (!(srcdir?.biDirectional && dstdir?.biDirectional)) {
					error('Connection source and destination must be bidirectional', assoc, null, MUST_BE_BI)
				}
			}
		} else if (assoc.associationType.isFeatureDelegate) {
			if (!assoc.isBidirectional){
				if (!(srcdir === dstdir || srcdir === FeatureDirection.NONE || dstdir === FeatureDirection.NONE)) {
					error('Feature delegate directions must be same', assoc, null, SAME_DIRECTION)
				}
				if (srcdir?.biDirectional && dstdir?.biDirectional) {
					// delegate direction must be bidirectional but is directional
					error('Feature delegate declaration must be bidirectional when source and destination are bidirectional', assoc, null, MUST_BE_BI)
				}
			} else {
				// bidirectional
				if (!(srcdir?.biDirectional && dstdir?.biDirectional)) {
					error('Feature delegate source and destination must be bidirectional', assoc, null, MUST_BE_BI)
				}
			}
		} else if (assoc.associationType.isFlowSpec) {
			if (srcdir !== null && dstdir !== null && !(srcdir.incoming && dstdir.outgoing)) {
				error('FLow path must be from incoming to outgoing', assoc, null, IN_TO_OUT)

			} else if (srcdir !== null && dstdir === null && !(srcdir.incoming)) {
				error('Flow sink must be incoming', assoc, Aadlv3Package.Literals.ASSOCIATION__SOURCE, MUST_BE_IN)
			} else if (srcdir === null && dstdir !== null && !(dstdir.outgoing)) {
				error('FLow source must be outgoing', assoc, Aadlv3Package.Literals.ASSOCIATION__DESTINATION,
					MUST_BE_OUT)
			}
		} else if (assoc.associationType.isBinding) {
			if (!(srcdir?.outgoingBinding && dstdir?.incomingBinding)) {
				error('Binding must be from requires to provides', assoc, null, REQUIRES_TO_PROVIDES)
			}
		}
	}

	def checkConsistentFeatureCategory(Association assoc) {
		if (assoc.source === null || assoc.destination === null) return
		val srcelem = assoc.source?.element 
		val dstelem = assoc.destination?.element 
		if (assoc.associationType.isConnection || assoc.associationType.isFeatureDelegate) {
		  if (srcelem instanceof Feature && dstelem instanceof Feature){
			val src = srcelem as Feature
			val dst = dstelem as Feature
			if (!(src?.category === dst?.category)) {
				error('Feature category of connection/delegate ends must match', assoc, null, MATCH_FEATURE_CATEGORY)
			}
		  } else if (srcelem instanceof Component && dstelem instanceof Feature){
			val srccat = (srcelem as Component).category
			val dstcat = (dstelem as Feature).category
			if (!categoriesMatch(srccat, dstcat)) {
				error('Feature category of connection/delegate ends must match', assoc, null, MATCH_FEATURE_CATEGORY)
			}
		  } else if (srcelem instanceof Feature && dstelem instanceof Component){
			val srccat = (srcelem as Feature).category
			val dstcat = (dstelem as Component).category
			if (!categoriesMatch(dstcat, srccat)) {
				error('Feature category of connection/delegate ends must match', assoc, null, MATCH_FEATURE_CATEGORY)
			}
		  }
	   } else if (assoc.associationType.isBinding) {
		  if (srcelem instanceof Feature && dstelem instanceof Feature){
			val src = srcelem as Feature
			val dst = dstelem as Feature
			if (!(src?.isBindingPoint && dst?.isBindingPoint)) {
				error('Binding must be between bindingpoints', assoc, null, MUST_BE_BINDING_POINT)
			}
		  }
		} else {
			// others should not have binding points
		  if (srcelem instanceof Feature && dstelem instanceof Feature){
			val src = srcelem as Feature
			val dst = dstelem as Feature
			if (src !== null && src.isBindingPoint || dst !== null && dst.isBindingPoint) {
				error('Bindingpoints can only be in bindings', assoc, null, NO_BINDING_POINT)
			}
		  }
		}
	}

	def checkConsistentTargets(Association assoc) {
		if (assoc.associationType.isConnection) {
			if (assoc.source === null || assoc.destination === null) return;
			if (!(assoc.source.modelElementReferenceIncludesComponent &&
				assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Connection must be between subcomponents', assoc, null, BetweenSubcomponents)
			}
		}
		if (assoc.associationType.isFeatureDelegate) {
			if (assoc.source === null || assoc.destination === null) return;
			val srcdir = assoc.source.realFeatureDirection
			if (srcdir?.outgoing) {
				if (!(assoc.source.modelElementReferenceIncludesComponent && !assoc.destination.modelElementReferenceIncludesComponent)) {
					error('Outgoing feature delegate must be from feature in subcomponent to feature', assoc, null, org.osate.xtext.aadlv3.validation.AadlV3Validator.FeatureAndSubcomponent)
				}
			} else {
				if (!(!assoc.source.modelElementReferenceIncludesComponent && assoc.destination.modelElementReferenceIncludesComponent)) {
					error('Feature delegate must be from feature to feature in subcomponent', assoc, null, org.osate.xtext.aadlv3.validation.AadlV3Validator.FeatureAndSubcomponent)
				}
			}
		} else if (assoc.associationType.isFlowSpec) {
			if (assoc.source !== null && assoc.destination !== null &&
				!(!assoc.source.modelElementReferenceIncludesComponent &&
					!assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Flow path must not be between features of subcomponents', assoc, null, BetweenFeatures)
			} else // } else if (assoc.associationType === AssociationType.FLOWSINK) {
			if (assoc.source !== null && assoc.destination === null &&
				!(!assoc.source.modelElementReferenceIncludesComponent)) {
				error('Flow sink must not be a subcomponent feature', assoc, Aadlv3Package.Literals.ASSOCIATION__SOURCE,
					NotSubcomponentFeature)
			} else // } else if (assoc.associationType === AssociationType.FLOWSOURCE) {
			if (assoc.source === null && assoc.destination !== null &&
				!(!assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Flow source must not be a subcomponent feature', assoc,
					Aadlv3Package.Literals.ASSOCIATION__DESTINATION, NotSubcomponentFeature)
			}
		} else if (assoc.associationType.isBinding) {
			if (!(!assoc.source.modelElementReferenceIncludesComponent &&
				!assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Binding must be between subcomponents', assoc, null, BetweenSubcomponents)
			}
		}
	}

	def checkMatchingTypes(Association assoc) {
		if(assoc.associationType.flowSpec) return;
		if (assoc.source === null || assoc.destination === null) return;
		val srcelem = assoc.source.element 
		val dstelem = assoc.destination.element 
		if (srcelem instanceof Feature && dstelem instanceof Feature){
			val src = srcelem as Feature
			val dst = dstelem as Feature
			if (src?.typeReference?.type !== null && dst?.typeReference?.type !== null && src?.typeReference?.type !== dst?.typeReference?.type) {
				error('Association ends must have same type', assoc, null, MatchingTypes)
			}
			if (src?.typeReference?.type !== null && dst?.typeReference?.type === null || src?.typeReference?.type === null && dst?.typeReference?.type !== null) {
				warning('One association end has a type, while the other does not', assoc, null, MissingOneType)
			}
		} else {
			val comptype = if (srcelem instanceof Component) {srcelem.typeReferences.head} else if (dstelem instanceof Component) { dstelem.typeReferences.head} else {null}
			val featype = if (srcelem instanceof Feature) {srcelem.typeReference} else if (dstelem instanceof Feature) { dstelem.typeReference} else {null}
			if (comptype === null && featype === null) {
				return;
			}
			if (comptype === null || featype === null) {
				warning('One association end has a type, while the other does not', assoc, null, MissingOneType)
			} else if (comptype.type !== featype.type){
				error('Association ends must have same type', assoc, null, MatchingTypes)
			}
		}
	}

	def checkPathSequenceConsistency(PathSequence path) {
		var PathElement prevPathElement = null
		for (pathElement : path.elements) {
			val element = pathElement.element
			val prevElement = prevPathElement?.element
			val elementidx = path.elements.indexOf(pathElement)
			if (prevElement instanceof Association) {
				if (prevElement.isFlowSpec) {
					// previous flow spec
					val prevdstcomp = prevPathElement.getClosestReferencedComponent
					if (element instanceof Association) {
						if (element.isFlowSpec) {
							// there must be a connection between them
						} else if (element.isConnection) {
							// connection must start from prev flow spec component
							val currentsrccomp = element.source.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Connection source component differs from destination component of preceding flow spec',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						}
					} else if (element instanceof Component) {
						// connection destination must be the component
						if (prevdstcomp !== element) {
							error('Component differs from destination component of preceding connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				} else if (prevElement.isConnection) {
					// previous connection
					val prevdstcomp = (prevElement as Association).destination.getClosestReferencedComponent
					if (element instanceof Association) {
						if (element.isFlowSpec) {
							val currentsrccomp = pathElement.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Component of flow spec differs from from destination component of preceding connection',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						} else if (element.isConnection) {
							// both are connection
							// they must connect to the same component
							val currentsrccomp = element.source.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Connection source component differs from destination component of preceding connection',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						}
					} else if (element instanceof Component) {
						// connection destination must be the component
						if (prevdstcomp !== element) {
							error('Component differs from destination component of preceding connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				}
			} else if (prevElement instanceof Component) {
				// previous component
				if (element instanceof Association) {
					if (element.isFlowSpec) {
						// there must be a connection
					} else if (element.isConnection) {
						// element is a connection
						// connection source must be same as prev component
						val currentsrccomp = element.source.getClosestReferencedComponent
						if (prevElement !== currentsrccomp) {
							error('Preceding component differs from source component of connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				} else if (element instanceof Component) {
					// both are component
					// there must be a connection
				}
			}
			prevPathElement = pathElement
		}
	}
	
	

}
