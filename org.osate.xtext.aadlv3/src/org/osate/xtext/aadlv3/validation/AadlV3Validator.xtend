/*
 * generated by Xtext 2.14.0
 */
package org.osate.xtext.aadlv3.validation

import com.google.common.collect.SetMultimap
import java.util.Collections
import java.util.Stack
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.osate.aadlv3.aadlv3.Aadlv3Factory
import org.osate.aadlv3.aadlv3.Aadlv3Package
import org.osate.aadlv3.aadlv3.Association
import org.osate.aadlv3.aadlv3.Subcomponent
import org.osate.aadlv3.aadlv3.ComponentCategory
import org.osate.aadlv3.aadlv3.Classifier
import org.osate.aadlv3.aadlv3.ComponentConfiguration
import org.osate.aadlv3.aadlv3.ComponentImplementation
import org.osate.aadlv3.aadlv3.ComponentInterface
import org.osate.aadlv3.aadlv3.ComponentRealization
import org.osate.aadlv3.aadlv3.ConfigurationActual
import org.osate.aadlv3.aadlv3.ClassifierAssignment
import org.osate.aadlv3.aadlv3.ConfigurationParameter
import org.osate.aadlv3.aadlv3.Feature
import org.osate.aadlv3.aadlv3.FeatureCategory
import org.osate.aadlv3.aadlv3.FeatureDirection
import org.osate.aadlv3.aadlv3.ModelElement
import org.osate.aadlv3.aadlv3.NamedElementReference
import org.osate.aadlv3.aadlv3.PathElement
import org.osate.aadlv3.aadlv3.PathSequence
import org.osate.aadlv3.aadlv3.PropertyAssociation
import org.osate.aadlv3.aadlv3.PropertyAssociationType
import org.osate.aadlv3.aadlv3.PropertyDefinition
import org.osate.aadlv3.aadlv3.TypeReference

import static extension org.osate.aadlv3.util.Av3API.*

import static extension org.osate.aadlv3.util.Aadlv3Util.*
import org.eclipse.emf.common.util.EList
import org.osate.aadlv3.aadlv3.TypeDef
import org.osate.aadlv3.util.Aadlv3Util
import org.osate.aadlv3.util.Av3API
import org.osate.aadlv3.util.Aadlv3GlobalScopeUtil
import java.util.Collection
import org.osate.aadlv3.aadlv3.ListLiteral
import org.osate.aadlv3.aadlv3.CompositeType
import org.osate.aadlv3.aadlv3.Composite
import org.osate.aadlv3.aadlv3.NamedElement

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AadlV3Validator extends AbstractAadlV3Validator {

	public static val DUPLICATE_NAMES = 'DuplicateNames'
	public static val ONLY_SUPER_INTERFACES = 'OnlySuperInterfaces'
	public static val NO_SUPER_INTERFACES = 'NoSuperInterfaces'
	public static val NO_SUPER_CONFIGURATIONS = 'NoSuperConfigurations'
	public static val BAD_BINDING_POINT_DIRECTION = 'BadBindingPointDirection'
	public static val BAD_BUS_ACCESS_DIRECTION = 'BadBusAccessDirection'
	public static val BAD_VIRTUAL_BUS_ACCESS_DIRECTION = 'BadVirtualBusAccessDirection'
	public static val BAD_SUBPROGRAM_ACCESS_DIRECTION = 'BadSubprogramAccessDirection'
	public static val BAD_SUBPROGRAM_GROUP_ACCESS_DIRECTION = 'BadSubprogramGroupAccessDirection'
	public static val BAD_DATA_ACCESS_DIRECTION = 'BadDataAccessDirection'
	public static val BAD_PORT_DIRECTION = 'BadPortDirection'
	public static val BAD_FEATURE_DIRECTION = 'BadFeatureDirection'
	public static val BAD_INTERFACE_DIRECTION = 'BadInterfaceDirection'
	public static val ONLY_INTERFACES_REVERSE = 'OnlyInterfacesReverse'
	public static val MISMATCHED_COMPONENT_CATEGORY = 'MismatchedCategory'
	public static val IN_TO_OUT = 'InToOut'
	public static val OUT_TO_IN = 'OutToIn'
	public static val SAME_DIRECTION = 'SameDirection'
	public static val REQUIRES_TO_PROVIDES = 'RequiresToProvides'
	public static val MUST_BE_OUT = 'MustBeOut'
	public static val MUST_BE_IN = 'MustBeIn'
	public static val MUST_BE_BI = 'MustBeBidirectional'
	public static val MATCH_FEATURE_CATEGORY = 'MatchFeatureCategory'
	public static val MUST_BE_BINDING_POINT = 'MustBeBindingPoint'
	public static val NO_BINDING_POINT = 'NoBindingPoint'
	public static val BetweenSubcomponents = 'BetweenSubcomponents'
	public static val ToSubcomponents = 'ToSubcomponents'
	public static val FeatureAndSubcomponent = 'FeatureAndSubcomponent'
	public static val NotSubcomponentFeature = 'NotSubcomponentFeature'
	public static val BetweenFeatures = 'BetweenFeatures'
	public static val MatchingTypes = 'MatchingTypes'
	public static val ToFlowSpec = 'ToFlowSpec'
	public static val MissingOneType = 'MissingOneType'
	public static val OnlyPropertyAssociations = 'OnlyPropertyAssociations'
	public static val MustBeDataType = 'MustBeDataType'
	public static val NoDataType = 'NoDataType'
	public static val FormalActualMismatch = 'FormalActualMismatch'
	public static val TypeMismatch = 'TypeMismatch'
	public static val ConfigurationPattern = 'ConfigurationPattern'
	public static val ParameterNotInterface = 'ParameterNotInterface'
	public static val OverrideType = 'OverrideType'
	public static val OneType = 'OneType'
	public static val DifferentComponentInPath = 'DifferentComponentInPath'
	public static val NoInterface = 'NoComponentInterface'
	public static val DoesNotApply = 'DoesNotApply'
	public static val NoOverride = 'NoOverride'
	public static val NoDoubleAssignment = 'NoDoubleAssignment'
	public static val NoFinalChange = 'NoFinalChange'
	public static val ConflictingFinal = 'ConflictingFinal'
	public static val ConflictingComposite = 'ConflictingComposite'
	public static val MustBeFinal = 'MustBeFinal'
	public static val NoCommonImplementation = 'NoCommonImplementation'
	public static val NoImplementation = 'NoImplementation'
	public static val MultipleImplementations = 'MultipleImplementations'
	public static val NoEvent = 'NoEvent'

	@Check
	def checkClassifier(Classifier cl) {
		cl.checkConsistentCategory()
		cl.checkSingleImplementationExtendsLineage
		cl.checkDuplicatePropertyAssociations
		cl.checkCompositePropertyAssociationConflict
	}

	@Check
	def checkComponentInterface(ComponentInterface cif) {
		cif.checkUniqueModelElementNames()
		cif.checkComponentInterfaceExtensions()
		cif.checkCompositeInterfacePAConflict()
	}

	@Check
	def checkComponentImplementation(ComponentImplementation cimpl) {
		cimpl.checkInterface()
		cimpl.checkUniqueModelElementNames()
		cimpl.checkComponentImplementationExtensions()
		cimpl.checkCompositeClassifierAssignmentFinalPropertyAssociationConsistency
	}

	@Check
	def checkComponentConfiguration(ComponentConfiguration config) {
		config.checkInterface()
		config.checkConsistentImplementationAssignmentsToSubcomponents
		config.checkCompositeClassifierAssignmentFinalPropertyAssociationConsistency
	}

	@Check
	def checkFeature(Feature fea) {
		fea.checkFeatureDirection()
		fea.checkFeatureEvent()
		fea.checkDuplicatePropertyAssociations
		if (fea.category != FeatureCategory.INTERFACE && fea?.typeReference?.isReverse) {
			error('Only interface features can reverse direction', fea, Aadlv3Package.Literals.FEATURE__TYPE_REFERENCE,
				ONLY_INTERFACES_REVERSE)
		}
	}

	@Check
	def checkAssociation(Association assoc) {
		assoc.checkConsistentDirection
		assoc.checkConsistentFeatureCategory
		assoc.checkConsistentTargets
		assoc.checkMatchingTypes
		assoc.checkDuplicatePropertyAssociations
	}

	@Check
	def checkClassifierAssignment(ClassifierAssignment ca) {
		ca.checkClassifierAssignmentCategory
		ca.checkSingleImplementationExtendsLineage
		ca.checkExtendsCAImplementation
		ca.checkExtendsSubcomponentImplementation
		ca.checkDuplicatePropertyAssociations
		ca.checkCompositePropertyAssociationConflict
	}

	@Check
	def checkPathSequence(PathSequence flowa) {
		// flow assignment or end to end path
		if (flowa.name === null || flowa.name.empty) {
			// flow assignment
			if (!(flowa.target.element instanceof Association && (flowa.target.element as Association).isFlowSpec)) {
				error('Flow assignment must be for flow specification', flowa,
					Aadlv3Package.Literals.PATH_SEQUENCE__TARGET, ToFlowSpec)
			}
		// the first and last path element may be feature mappings
		}
		// for both the sequence has to be consistent
		flowa.checkPathSequenceConsistency
		flowa.checkDuplicatePropertyAssociations
	}

	@Check
	def checkPathElement(PathElement pe) {
		if (!(pe.element instanceof Association &&
			((pe.element as Association).isFlowSpec || (pe.element as Association).isConnection ||
				(pe.element as Association).isFeatureDelegation) || pe.element instanceof Subcomponent)) {
			error('Path element must reference a connection, flow spec, or component', pe, null, ToFlowSpec)
		}
	}

	@Check
	def checkSubcomponent(Subcomponent comp) {
		comp.checkConsistentCategory
		comp.checkSingleImplementationExtendsLineage
		comp.checkDuplicatePropertyAssociations
	}

	@Check
	def checkConfigurationParameter(ConfigurationParameter param) {
		if (!(param.type instanceof ComponentInterface)) {
			error('Configuration parameter type is not a component interface', param,
				Aadlv3Package.Literals.CONFIGURATION_PARAMETER__TYPE, ParameterNotInterface)
		}
	}

	@Check
	def checkConfigurationActual(ConfigurationActual ca) {
		val cif = ca.parameter.type
		if (cif instanceof Classifier) {
			val assignedtypes = ca.assignedClassifiers
			for (assignedtyperef : assignedtypes) {
				val assignedtype = assignedtyperef.type
				if (assignedtype instanceof Classifier) {
					if (!(cif.isSuperClassifierOf(assignedtype))) {
						error('Configuration actual does not match component classifier of configuration parameter', ca,
							null, FormalActualMismatch)
					}
				} else if (assignedtype instanceof TypeDef) {
					error(
						'Configuration actual (data type) does not match component classifier of configuration parameter',
						ca, null, FormalActualMismatch)
				} else if (assignedtype instanceof ConfigurationParameter) {
					val assignedcif = assignedtype.type
					if (assignedcif instanceof Classifier) {
						if (!(cif.isSuperClassifierOf(assignedcif))) {
							error(
								'Configuration actual is not an extension of component classifier of referenced configuration parameter',
								ca, null, FormalActualMismatch)
						}
					}
				} else {
					// should be an assigned component classifier
					error('Configuration actual is not a component classifier', ca, null, FormalActualMismatch)
				}
			}
		} else if (cif instanceof TypeDef) {
			val assignedtypes = ca.assignedClassifiers
			for (assignedtyperef : assignedtypes) {
				val assignedtype = assignedtyperef.type
				if (assignedtype instanceof Classifier) {
					error(
						'Configuration actual (component classifier) does not match configuration parameter data type',
						ca, null, FormalActualMismatch)
				} else if (assignedtype instanceof TypeDef) {
					if (!(cif.isSuperTypeOf(assignedtype))) {
						error(
							'Configuration actual (data type) is not an extension of configuration parameter data type',
							ca, null, FormalActualMismatch)
					}
				} else if (assignedtype instanceof ConfigurationParameter) {
					val assignedcif = assignedtype.type
					if (assignedcif instanceof Classifier) {
						error(
							'Configuration actual (component classifier) does not match referenced configuration parameter data type',
							ca, null, FormalActualMismatch)
					}
				} else {
					// should be an assigned component classifier
					error('Configuration actual is not a component classifier', ca, null, FormalActualMismatch)
				}
			}
		}
	}

	@Check
	def checkPropertyAssociation(PropertyAssociation pa) {
		pa.checkDuplicatePropertyAssociationForLocalModelElementTarget
		pa.checkPropertyAssociationTypeConsistency
		pa.checkPropertyAssociationAppliesto
		pa.checkWhenPropertyAssociationMustBeFinal
		pa.checkLocalPAOverridesSuperClassifierLocalFinalPA
		pa.checkSubcomponentPAOverridesLocalFinalPA
		pa.checkFinalPAOverridesLocalFinalPA
	}

	/**
	 * Check that the assigned value is consistent with the property type
	 * This will be handled by Lutz' expression language
	 */
	def checkPropertyAssociationTypeConsistency(PropertyAssociation pa) {
		val pdt = pa.property.type
		val pe = pa.value
		switch( pe){
			ListLiteral: {
				if (!((pdt instanceof CompositeType)&&(pdt as CompositeType).compositeType === Composite.LIST)){
					error(
						"Property value is not of type 'list'",
						pa, null, TypeMismatch)
				}
			}
			TypeReference: {
				if (!(pdt instanceof TypeReference)){
					error(
						"property value is not of type 'type'",
						pa, null, TypeMismatch)
				}
			}
			default: {}
		}
		
	}

	/**
	 * check that it is assigned to a model element that can accept the property
	 */
	def checkPropertyAssociationAppliesto(PropertyAssociation pa) {
		if (pa.target !== null) {
			val targetme = pa.target.element
			switch (targetme) {
				Subcomponent: {
					if (!pa.property.appliesToCategory(targetme.category)) {
						val allowedUse = targetme.typeReferences.allowedUseProperties
						if (allowedUse.empty) {
							error('Property does not apply to ' + targetme.category, pa,
								Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
						} else {
							if (!allowedUse.exists[pd|samePropertyDefinition(pd, pa.property)]) {
								error('Property does not apply to subcomponent ' + targetme.name, pa,
									Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
							}
						}
					}
				}
				Feature: {
					if (!pa.property.appliesToCategory(targetme.category)) {
						error('Property does not apply to ' + targetme.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Association: {
					if (!pa.property.appliesToCategory(targetme.associationType)) {
						error('Property does not apply to ' + targetme.associationType, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
			}
		} else {
			// associated with containing element
			val paTarget = pa.eContainer
			switch (paTarget) {
				Subcomponent: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to ' + paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Classifier: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to ' + paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Feature: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to ' + paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Association: {
					if (!pa.property.appliesToCategory(paTarget.associationType)) {
						error('Property does not apply to ' + paTarget.associationType, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
			}
		}
	}

	/**
	 * check the PA is FINAL when in configuration, CA, or reachdown
	 */
	def checkWhenPropertyAssociationMustBeFinal(PropertyAssociation pa) {
		if (pa.isConfiguredPropertyAssociation) {
			if (pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE) {
				error('Property assignment in configuration assignment must be final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
		}
	}

	def isConfiguredPropertyAssociation(PropertyAssociation pa) {
		return pa.eContainer instanceof ClassifierAssignment || pa.containingClassifier instanceof ComponentConfiguration ||
			 pa.target.modelElementReferenceReachDown
	}

	/**
	 * Check whether target model element of configuration, CA or reachdown PA has a locally assigned FINAL value
	 * Locally assigned is by PA in classifier without target or model element of classifier other than component by {} or MER
	 */
	def checkFinalPAOverridesLocalFinalPA(PropertyAssociation pa) {
		if(pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE) return;
		if (pa.eContainer instanceof ClassifierAssignment) {
			if (pa.target !== null && pa.target.element.hasLocalFinalPropertyAssociation(pa.property)) {
				error('Locally assigned property value is already final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		} else if (pa.eContainer instanceof ComponentConfiguration) {
			if (pa.target !== null && pa.target.element.hasLocalFinalPropertyAssociation(pa.property)) {
				error('Locally assigned property value is already final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		} else if (pa.target.modelElementReferenceReachDown) {
			if (pa.target.element.hasLocalFinalPropertyAssociation(pa.property)) {
				error('Locally assigned property value is already final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		}
	}

	def hasLocalFinalPropertyAssociation(NamedElement ne, PropertyDefinition pd) {
		if (ne instanceof Subcomponent) {
			// all PA in classifiers listed in component & PA in {} of component
			val pas = ne.typeReferences.allPropertyAssociations + ne.ownedPropertyAssociations
			// PA with PD exists and does not have a target, i.e., is for the component and is FINAL
			pas.exists [ pa |
				samePropertyDefinition(pa.property, pd) && pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					pa.target === null
			]
		} else {
			// PA in {} & PA in enclosing classifier with ne as target
			val clpas = ne.containingClassifier.allPropertyAssociations
			val mepas = ne.ownedPropertyAssociations
			clpas.exists [ pa |
				samePropertyDefinition(pa.property, pd) && pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					pa.target === ne
			] || mepas.exists [ pa |
				samePropertyDefinition(pa.property, pd) && pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					pa.target === null
			]
		}
		return false
	}

	/**
	 * check override of final local PAs by subcomponent PA reachdown or {}
	 */
	def checkSubcomponentPAOverridesLocalFinalPA(PropertyAssociation pa) {
		if (pa.target !== null && pa.target.element instanceof Subcomponent) {
			// PA points to component
			val targetme = pa.target.element as Subcomponent
			// for all property assignments to components, if the declared component classifier(s) already has a local assignment that is final
			val tpas = targetme.typeReferences.allPropertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && samePropertyDefinition(tpa.property, pa.property) &&
					tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error('Property association cannot change final value assigned via classifier ' +
						tpa.containingClassifier.name, pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
				}
			}
		}
		if (pa.target === null && pa.eContainer instanceof Subcomponent) {
			// associated with containing element. target is null
			val paTarget = pa.eContainer as Subcomponent
			val tpas = paTarget.typeReferences.allPropertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && samePropertyDefinition(tpa.property, pa.property) &&
					tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error(
						'Property association cannot change final value assigned via classifier ' +
							tpa.containingClassifier.name + ' of enclosing component ' + paTarget.name, pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
				}
			}
		}
	}

	/**
	 * check whether pa overrides local final PA in super classifier
	 */
	def checkLocalPAOverridesSuperClassifierLocalFinalPA(PropertyAssociation pa) {
		// for all model elements the enclosing classifier's super classifiers can have assigned a FINAL value
		if (pa.target === null) return;
		if(pa.target.modelElementReferenceReachDown) return;
		// target is null or to a local ME
		val me = pa.target?.element
		val supercls = pa.containingClassifier.allSuperClassifiers
		for (supercl : supercls) {
			val spas = supercl.ownedPropertyAssociations
			for (spa : spas) {
				if (spa.target === me && samePropertyDefinition(spa.property, pa.property) &&
					spa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error('Property association cannot change final value assigned in ' + supercl.name, pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
				}
			}
		}
	}

	/**
	 * check duplicate PA via {} and local enclosing PA 
	 */
	def checkDuplicatePropertyAssociationForLocalModelElementTarget(PropertyAssociation pa) {
		if (pa.target === null) return;
		if ( !pa.target.modelElementReferenceReachDown) {
			val context = pa.containingClassifier
			val targetme = pa.target.element
			val targetcontext = targetme.containingClassifier
			// local target model element also has {} property assignment 
			val tpas = targetme.ownedPropertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && samePropertyDefinition(tpa.property, pa.property) && context == targetcontext) {
					error('Property value also assigned in {}', pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, NoDoubleAssignment)
				}
			}
		}
	}
	
		/**
	 * check duplicate PA via =>{} and reachdown PA 
	 */
	def checkDuplicatePropertyAssociationForReachDownModelElementTarget(PropertyAssociation pa) {
		if (pa.target === null) return;
		if ( !pa.target.modelElementReferenceReachDown) {
			val context = pa.containingClassifier
			val targetme = pa.target.element
			val targetcontext = targetme.containingClassifier
			// local target model element also has {} property assignment 
			val tpas = targetme.ownedPropertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && samePropertyDefinition(tpa.property, pa.property) && context == targetcontext) {
					error('Property value also assigned in {}', pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, NoDoubleAssignment)
				}
			}
		}
	}
	

	/**
	 * check duplicate PA in classifier
	 */
	def checkDuplicatePropertyAssociations(Classifier cl) {
		checkDuplicatePropertyAssociations(cl.ownedPropertyAssociations, cl,
			Aadlv3Package.Literals.NAMED_ELEMENT__OWNED_PROPERTY_ASSOCIATIONS)
	}

	/**
	 * check duplicate PA in CA
	 */
	def checkDuplicatePropertyAssociations(ClassifierAssignment ca) {
		checkDuplicatePropertyAssociations(ca.ownedPropertyAssociations, ca,
			Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__OWNED_PROPERTY_ASSOCIATIONS)
	}

	/**
	 * check duplicate PA in Model Element
	 */
	def checkDuplicatePropertyAssociations(ModelElement me) {
		checkDuplicatePropertyAssociations(me.ownedPropertyAssociations, me,
			Aadlv3Package.Literals.NAMED_ELEMENT__OWNED_PROPERTY_ASSOCIATIONS)
	}

	def checkDuplicatePropertyAssociations(Iterable<PropertyAssociation> pas, EObject target,
		EStructuralFeature structuralfeature) {
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && samePropertyAndPath(first, second) ) {
					error('Duplicate property association ' + first.property.name, target, structuralfeature, secondidx,
						NoDoubleAssignment)
					error('Duplicate property association ' + second.property.name, target, structuralfeature, firstidx,
						NoDoubleAssignment)
				}
			}
		}
	}

	/**
	 * conflicting PA in super interfaces of given interface without local override. 
	 */
	def checkCompositeInterfacePAConflict(ComponentInterface cl) {
		val pas = cl.superClassifiers.allPropertyAssociations
		val localpas = cl.ownedPropertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			val firstPath = first.target.targetPath
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				val secondPath = second.target.targetPath
				if (samePropertyAndPath(first, second) && !first.overridesPropertyAssociation(second)) {
					// is there a local override
					if (!contains(localpas,first)){
					error(
						'In interface composition property association ' + (second.eContainer as Classifier).name + '::' +
							secondPath + '#' + second.property.name + ' conflicts with ' +
							(first.eContainer as Classifier).name + '::' + firstPath + '#' +
							first.property.name, cl, Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS,
						cl.superClassifiers.indexOf(second.eContainer), ConflictingComposite)
					}
				}
			}
		}
	}


	/**
	 * conflicting PA in assigned classifiers of CA
	 */
	def checkCompositePropertyAssociationConflict(ClassifierAssignment ca) {
		checkCompositeClassifierPropertyAssociationConflict(ca,ca.assignedClassifiers, ca.ownedPropertyAssociations)
	}
	

	/**
	 * conflicting PA in assigned classifiers of configuration extends
	 */
	def checkCompositePropertyAssociationConflict(Classifier conf) {
		checkCompositeClassifierPropertyAssociationConflict(conf,conf.superClassifiers, conf.ownedPropertyAssociations)
	}

	def checkCompositeClassifierPropertyAssociationConflict(EObject trscontainer, EList<TypeReference> trs, EList<PropertyAssociation> locaPAs) {
		val pas = trs.allPropertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			// check for conflict between PAs from assigned classifiers
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (samePropertyValueAssignment(first, second)  ) {
						if (trscontainer instanceof Classifier){
					error(
						'Property association ' + second.containingClassifier.name + '::' +
							second.target.targetPath + '#' + second.property.name + ' conflicts with ' +
							first.containingClassifier.name + '::' + first.target.targetPath + '#' +
							first.property.name, trscontainer,
						Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS,
						trs.getIndex(second.containingClassifier), ConflictingComposite)
						} else {
							// CA
					error(
						'Property association ' + second.containingClassifier.name + '::' +
							second.target.targetPath + '#' + second.property.name + ' conflicts with ' +
							first.containingClassifier.name + '::' + first.target.targetPath + '#' +
							first.property.name, trscontainer,
						Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
						trs.getIndex(second.containingClassifier), ConflictingComposite)
						}
				}
			}
						// check PA in {} of CA for conflict with PAs from assigned classifiers
			for (curlypa : locaPAs) {
				if (samePropertyValueAssignment(first, curlypa) ) {
						if (trscontainer instanceof Classifier){
					error(
						'Property association ' + curlypa.target.targetPath + '#' + curlypa.property.name +
							' conflicts with ' + first.containingClassifier.name + '::' +
							first.target.targetPath + '#' + first.property.name, trscontainer,
						Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS,
						locaPAs.indexOf(curlypa), ConflictingComposite)
							
						} else {
							// CA
					error(
						'Property association ' + curlypa.target.targetPath + '#' + curlypa.property.name +
							' conflicts with ' + first.containingClassifier.name + '::' +
							first.target.targetPath + '#' + first.property.name, trscontainer,
						Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__OWNED_PROPERTY_ASSOCIATIONS,
						locaPAs.indexOf(curlypa), ConflictingComposite)
						}
				}
			}
			
		}
	}


	def int getIndex(Iterable<TypeReference> trs, EObject cl) {
		var cnt = 0
		for (tr : trs) {
			if(tr.type === cl) return cnt
			cnt++
		}
		return -1
	}

	def TypeReference getTypeReference(Iterable<TypeReference> trs, EObject cl) {
		for (tr : trs) {
			if(tr.type === cl) return tr
		}
		return null
	}

	/**
	 * check FINAL PA based on configured components.
	 * casscopes maintains a stack of CAs down the component hierarchy. For each level it is all CAs including those declared nested in other CAs
	 * reachdownPAS maintains a stack of reachdown PAs declared in classifiers configured for the component
	 */
	def void checkCompositeClassifierAssignmentFinalPropertyAssociationConsistency(ComponentRealization cl) {
		val subs = cl.allSubcomponents
		val casscopes = new Stack<Iterable<ClassifierAssignment>>()
		val cas = cl.allClassifierAssignments
		val caspas = cas.map[ca|ca.ownedPropertyAssociations].flatten
		checkCompositeCasPasConflict(caspas, cl)
		casscopes.push(cas)
		val reachdownPAS = new Stack<Iterable<PropertyAssociation>>()
		reachdownPAS.push(cl.allPropertyAssociations.filter[pa|pa.target.modelElementReferenceReachDown])
		for (sub : subs) {
			val rootmer = Aadlv3Factory.eINSTANCE.createNamedElementReference
			rootmer.element = sub
			checkNestedPAS(rootmer, casscopes, reachdownPAS, cl)
		}
	}

	def void checkNestedPAS(NamedElementReference context, Stack<Iterable<ClassifierAssignment>> casscopes,
		Stack<Iterable<PropertyAssociation>> reachdownPAS, ComponentRealization rootcl) {
		val comp = context.element as Subcomponent
		var Iterable<TypeReference> trefs = null
		// subcomponent
		trefs = comp.getConfiguredTypeReferences(casscopes)
		if (trefs === null) {
			// inline subcomponents without explicit classifier
			casscopes.push(Collections.EMPTY_LIST)
			reachdownPAS.push(comp.ownedPropertyAssociations.filter[pa|pa.target.modelElementReferenceReachDown])
			comp.components.forEach[subc|context.addComponent(subc).checkNestedPAS(casscopes, reachdownPAS, rootcl)]
			casscopes.pop
			reachdownPAS.pop
		} else {
			val configuredPAS = trefs.allPropertyAssociations.filter[cpa|cpa.isConfiguredPropertyAssociation]
			checkConfiguredCompositePropertyAssociationFinalConflict(configuredPAS, comp, trefs)
			checkReachDownConflict(reachdownPAS, context, configuredPAS, rootcl)
			checkReachDownConfiguredPasConflict(casscopes, context, configuredPAS, rootcl)
			// all CAs including nested ones
			val cas = trefs.allClassifierAssignments
			val caspas = cas.map[ca|ca.ownedPropertyAssociations].flatten
			checkReachDownCasPasConflict(casscopes, context, caspas, rootcl)
			checkCompositeCasPasConflict(caspas, rootcl)
			val comps = trefs.getAllSubcomponents(comp)
			casscopes.push(cas)
			reachdownPAS.push(configuredPAS)
			comps.forEach[subc|context.addComponent(subc).checkNestedPAS(casscopes, reachdownPAS, rootcl)]
			casscopes.pop
			reachdownPAS.pop
		}
	}

	/**
	 * conflict between reachdown and configured PA
	 */
	def void checkReachDownConflict(Stack<Iterable<PropertyAssociation>> reachdownPAS, NamedElementReference context,
		Iterable<PropertyAssociation> configuredPAS, Classifier rootcl) {
		val n = reachdownPAS.size
		if(n === 0) return;
		for (k : n - 1 .. 0) {
			for (rdPA : reachdownPAS.get(k)) {
				for (configuredPA : configuredPAS) {
					if (matchesReachDown(rdPA.target, configuredPA.target, n - k, context)) {
						// error
						val rdcont = rdPA.eContainer
						if (rdcont instanceof Classifier) {
							error(
								'Final property association ' + rdPA.target.targetPath + '#' + rdPA.property.name +
									' conflicts with final ' + (configuredPA.eContainer as Classifier).name +
									'::' + configuredPA.target.targetPath + '#' + configuredPA.property.name +
									'configured for component ' + context.element.name, rdcont,
								Aadlv3Package.Literals.NAMED_ELEMENT__OWNED_PROPERTY_ASSOCIATIONS,
								rdcont.ownedPropertyAssociations.indexOf(rdPA), ConflictingFinal)
						}
					}
				}
			}
		}
	}

	def void checkReachDownConfiguredPasConflict(Stack<Iterable<ClassifierAssignment>> casscopes,
		NamedElementReference context, Iterable<PropertyAssociation> configuredPAS, Classifier rootcl) {
		val n = casscopes.size
		if(n === 0) return;
		for (k : n - 1 .. 0) {
			for (ca : casscopes.get(k)) {
				val rdpas = ca.ownedPropertyAssociations
				for (rdPA : rdpas) {
					// PAS from configured classifiers
					for (configuredPA : configuredPAS) {
						if (matchesReachDown(rdPA.target, configuredPA.target, n - k, context)) {
							// error
							val rdcont = rdPA.eContainer
							if (rdcont instanceof Classifier) {
								if (configuredPA.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
									rdPA.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
								error(
									'Final property association ' + rdPA.target.targetPath + '#' + rdPA.property.name +
										' conflicts with final ' +
										(configuredPA.eContainer as Classifier).name + '::' +
										configuredPA.target.targetPath + '#' + configuredPA.property.name, rdcont,
									Aadlv3Package.Literals.NAMED_ELEMENT__OWNED_PROPERTY_ASSOCIATIONS,
									rdcont.ownedPropertyAssociations.indexOf(rdPA), ConflictingFinal)
							}
							
							}
						}
					}
				}
			}
		}
	}

	def void checkReachDownCasPasConflict(Stack<Iterable<ClassifierAssignment>> casscopes,
		NamedElementReference context, Iterable<PropertyAssociation> casPAS, Classifier rootcl) {
		val n = casscopes.size
		if(n === 0) return;
		for (k : n - 1 .. 0) {
			for (ca : casscopes.get(k)) {
				val rdpas = ca.ownedPropertyAssociations
				for (rdPA : rdpas) {
					// PAS from configured classifiers
					for (casPA : casPAS) {
						if (matchesReachDown(rdPA.target, casPA.target, n - k, context)) {
							// error
							val rdcont = rdPA.eContainer
							if (rdcont instanceof Classifier) {
								if (casPA.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
									rdPA.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
									error(
										'Final property association ' + rdPA.target.targetPath + '#' +
											rdPA.property.name + ' conflicts with final ' +
											(casPA.eContainer as Classifier).name + '::' +
											casPA.target.targetPath + '#' + casPA.property.name, rdcont,
										Aadlv3Package.Literals.NAMED_ELEMENT__OWNED_PROPERTY_ASSOCIATIONS,
										rdcont.ownedPropertyAssociations.indexOf(rdPA), ConflictingFinal)
								}
							}
						}
					}
				}
			}
		}
	}

	def void checkCompositeCasPasConflict(Iterable<PropertyAssociation> casPAS, ComponentRealization rootcl) {
		val n = casPAS.size
		for (var firstidx = 0; firstidx < n - 1; firstidx++) {
			val first = casPAS.get(firstidx)
			val firstP = first.targetPath
			for (var secondidx = firstidx + 1; secondidx < n; secondidx++) {
				val second = casPAS.get(secondidx)
				val secondP = second.targetPath
				if (samePropertyDefinition(first.property, second.property) &&
					firstP == secondP &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error(
						'Final property association ' + secondP + '#' + second.property.name +
							' conflicts with final ' + firstP + '#' + first.property.name, rootcl,
						Aadlv3Package.Literals.COMPONENT_REALIZATION__CLASSIFIER_ASSIGNMENTS,
						rootcl.classifierAssignments.indexOf(second.eContainer), ConflictingFinal)
				}
			}
		}
	}

	/**
	 * conflicting PA in configured classifiers of component
	 */
	def checkConfiguredCompositePropertyAssociationFinalConflict(Iterable<PropertyAssociation> pas, Subcomponent comp,
		Iterable<TypeReference> trefs) {
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (samePropertyDefinition(first.property, second.property) &&
					first.target?.targetPath == second.target?.targetPath &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					val firsttref = trefs.getTypeReference(first.eContainer)
					val secondtref = trefs.getTypeReference(second.eContainer)
					if (firsttref.eContainer === secondtref.eContainer) {
						if (firsttref.eContainer instanceof ClassifierAssignment) {
							// in same CA
							// already handled
//							val ca = firsttref.eContainer as ClassifierAssignment
//							error(
//								'coProperty association '+ (second.eContainer as Classifier).name + '::' + second.target.targetPath + '#' + second.property.name +
//									' conflicts with ' + (first.eContainer as Classifier).name + '::' +
//									first.target.targetPath + '#' + first.property.name, ca,
//								Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
//								ca.assignedClassifiers.indexOf(secondtref), ConflictingFinal)
						} else if (first.eContainer instanceof Classifier) {
							// super classifiers
							// already handled
//							val cl = secondtref.eContainer as Classifier
//							error(
//								'coProperty association ' + (second.eContainer as Classifier).name + '::' +
//									second.target.targetPath + '#' + second.property.name + ' conflicts with ' +
//									(first.eContainer as Classifier).name + '::' + first.target.targetPath +
//									'#' + first.property.name, cl,
//								Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS,
//								cl.superClassifiers.indexOf(secondtref), ConflictingFinal)
						}
					} else {
						error(
							'Configured component ' + comp.name + ' property association ' +
								(second.eContainer as Classifier).name + '::' +
								second.target.targetPath + '#' + second.property.name + ' conflicts with ' +
								(first.eContainer as Classifier).name + '::' + first.target.targetPath + '#' +
								first.property.name, comp, Aadlv3Package.Literals.SUBCOMPONENT__TYPE_REFERENCES,
							trefs.getIndex(second.eContainer), ConflictingFinal)
					}
				}
			}
		}
	}

	def checkUniqueModelElementNames(ComponentInterface cl) {
		val mels = cl.allModelElements.toList
		val max = mels.length
		for (var firstidx = 0; firstidx < max - 1; firstidx++) {
			val first = mels.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < max; secondidx++) {
				val second = mels.get(secondidx)
				if (first !== second && first.name == second.name) {
					reportDuplicateNames(first, cl)
					reportDuplicateNames(second, cl)
				}
			}
		}
	}

	def checkInterface(ComponentRealization cimpl) {
		val interface = getInterface(cimpl);
		if (interface === null) {
			error('Could not find Component Interface '+Aadlv3Util.stripExtensionInName(cimpl.getName()), cimpl, null, FormalActualMismatch)
		}
	}

	def checkPattern(ComponentConfiguration config) {
		if (config.superClassifiers.empty) {
			if (!config.classifierAssignments.empty && !config.bindings.empty)
				error('Configurations without extend must only contain configuration assignment patterns', config,
					Aadlv3Package.Literals.COMPONENT_REALIZATION__CLASSIFIER_ASSIGNMENTS, ConfigurationPattern)
		}
	}

	def checkUniqueModelElementNames(ComponentImplementation cl) {
		val mels = cl.allModelElements.toList
		val maxmels = mels.length
		for (var firstidx = 0; firstidx < maxmels - 1; firstidx++) {
			val first = mels.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxmels; secondidx++) {
				val second = mels.get(secondidx)
				if (first !== second && first.name == second.name) {
					// do not report same name of model elements inherited from interface
					if (first.containingClassifier === cl || second.containingClassifier === cl) {
						reportDuplicateNames(first, cl)
						reportDuplicateNames(second, cl)
					}
				}
			}
		}
	}

	def void reportDuplicateNames(ModelElement first, Classifier cl) {
		val firstcl = first.containingClassifier
		if (firstcl === cl) {
			error('Duplicate model element with name ' + first.name, first, Aadlv3Package.Literals.NAMED_ELEMENT__NAME,
				DUPLICATE_NAMES)
		} else {
			var idx = 0;
			for (sclref : cl.superClassifiers) {
				val scl = sclref.type as Classifier
				if (firstcl.isSuperClassifierOf(scl)) {
					idx = cl.superClassifiers.indexOf(sclref)
				}
			}
			error('Duplicate model element with name ' + first.name, cl,
				Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS, idx, DUPLICATE_NAMES)
		}
	}

	def checkComponentInterfaceExtensions(ComponentInterface cif) {
		if (!cif.superClassifiers.forall[scif|scif.type instanceof ComponentInterface]) {
			error('Interface extensions must be interfaces', cif,
				Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS, ONLY_SUPER_INTERFACES)
		}
	}

	def checkComponentImplementationExtensions(ComponentImplementation cim) {
		val allcl = cim.superClassifiers
		if (allcl.exists[scil|scil.type instanceof ComponentInterface]) {
			error('Implementations cannot extend interfaces', cim,
				Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS, NO_SUPER_INTERFACES)
		}
		if (allcl.exists[scil|scil.type instanceof ComponentConfiguration]) {
			error('Implementations cannot extend configurations', cim,
				Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS, NO_SUPER_CONFIGURATIONS)
		}
	}

	/**
	 * Checks that the implementations are in single extends lineage
	 */
	def void checkSingleImplementationExtendsLineage(Classifier cl) {
		var ComponentImplementation top = null
		val trs = cl.superClassifiers
		for (tr : trs) {
			if (tr.type instanceof Classifier) {
				val topimpl = (tr.type as Classifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)) {
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)) {
					error('Implementation '+topimpl.name+' is not in extends lineage with implementation ' + top.name, cl,
						Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS, trs.indexOf(tr),
						NoCommonImplementation)
				}
			}
		}
	}

	/**
	 * Checks that the implementations are in single extends lineage
	 */
	def void checkSingleImplementationExtendsLineage(Subcomponent sub) {
		var ComponentImplementation top = null
		val trs = sub.typeReferences
		for (tr : trs) {
			val type = tr.type
			if (type instanceof Classifier) {
				val topimpl = type.topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)) {
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)) {
					error('Implementation '+topimpl.name+' is not in extends lineage with implementation ' + top.name, sub,
						Aadlv3Package.Literals.SUBCOMPONENT__TYPE_REFERENCES, trs.indexOf(tr), NoCommonImplementation)
				}
			}
		}
	}

	def void checkConsistentCategory(Subcomponent comp) {
		for (tr : comp.typeReferences) {
			val t = tr.type
			if (t instanceof Classifier) {
				// the categories must be consistent
				val clcat = (tr.type as Classifier).componentCategory
				if (!(clcat === comp.category || clcat === ComponentCategory.INTERFACE)) {
					error('Component category conflicts with classifier category', comp,
						Aadlv3Package.Literals.SUBCOMPONENT__CATEGORY, MISMATCHED_COMPONENT_CATEGORY)
				}
				// data component cannot have classifier, only primitive type
				if (comp.category === ComponentCategory.DATA) {
					error('Data component must have data type', comp, Aadlv3Package.Literals.SUBCOMPONENT__CATEGORY,
						MustBeDataType)
				}
			} else if (t instanceof TypeDef) {
				if (!(comp.category === ComponentCategory.DATA || comp.category === ComponentCategory.INTERFACE)) {
					error('Components other than "data" or "component" cannot have primitive type', comp,
						Aadlv3Package.Literals.SUBCOMPONENT__CATEGORY, NoDataType)
				}
			} else {
				// configuration parameter
			}
		}
		// if has type references that are not data type then {} can only contain property associations
		if (!comp.typeReferences.empty && ! comp.typeReferences.isTypeDef &&
			(!comp.features.empty || !comp.connections.empty || !comp.components.empty)) {
			error('Component with classifier can only have property associations in {}', comp, null,
				OnlyPropertyAssociations)
		}

	}



	/**
	 * check consistency of declared and assigned classifiers for all subcomponents
	 * If subcomponent has assigned implementation we already checked for CA not extending the implementation 
	 * Here we check that there is an explicit implementation assigned by CA and no configuration extends it
	 */

	def void checkConsistentImplementationAssignmentsToSubcomponents(ComponentConfiguration cl) {
		val SetMultimap<String, TypeReference> map = cl.cacheClassifierAssignments
		val keys = map.keySet
		for (key : keys) {
			val trs = map.get(key)
			trs.consistentComponentmplementationAssignmentsToSubcomponents(cl, key)
		}
	}
	
	/**
	 * check for consistent assignment of implementation
	 * Given a collection of classifier assignments via CA or directly a component
	 * check that 1) no implementation is assigned
	 * 1a) only one configuration is assigned (and its implementation is used)
	 * 1b) multiple configurations are assigned and all extend from the same implementation
	 *     and if different don't report if enclsoing classifiers are same or one is extends of other and neither is rootCl (cc)
	 * 2) one implementation is assigned and all assigned configurations have the same or super implementation
	 * 3) multiple implementations are assigned and
	 *    3a) subcomponent has implementation and all configuration implementations are the same or super
	 *    3b) subcomponent has no implementation and all implementations assigned by CA must be the same
	 */
	def void consistentComponentmplementationAssignmentsToSubcomponents(Iterable<TypeReference> trs, Classifier cc, String key) {
		// TODO handle assignment of configuration to subcomponent
		if (trs.empty) return;
		val assignedimpls = trs.componentImplementationTrs
		val assignedconfigs = trs.componentConfigurationTrs
		if (assignedimpls.empty) {
			if (assignedconfigs.size > 1){
				val firstconfig = assignedconfigs.get(0)
				val firstimpl = firstconfig.type.topComponentImplementation
			var same = true
				// all configured impls must be the same impl
				for (tr : assignedconfigs) {
					if (firstimpl !== tr.type.topComponentImplementation) {
						same = false;
					}
				}
				if (!same){
			error(
				'Subcomponent ' + key + ' has configuration assignments but no explicitly assigned implementation',
				cc, Aadlv3Package.Literals.NAMED_ELEMENT__NAME, NoImplementation)
				}
			}
		} else if (assignedimpls.size > 1) {
			val firstimpl = assignedimpls.get(0)
			val firstcontainingCl = firstimpl.containingClassifier
			var TypeReference subimpltr = null
			// do we have an impl assigned to subcomponent
			for (tr : assignedimpls) {
				if (tr.eContainer instanceof Subcomponent) {
					subimpltr = tr;
				}
			}
			var reportdifferent = false
			if (subimpltr === null) {
				// all configured impls must be the same impl
				for (tr : assignedimpls) {
					// report different if they came from different enclosing classifiers
					val trcontCl = tr.containingClassifier
					if (firstimpl.type !== tr.type && firstcontainingCl !== trcontCl){
						// skip if one is extends of other if neither are cc
						if( cc !== firstcontainingCl && cc !== trcontCl){
							if ( !( firstcontainingCl.isSuperClassifierOf(trcontCl) ||trcontCl.isSuperClassifierOf(firstcontainingCl) )){
								reportdifferent = true;
							}
						} else {
							reportdifferent = true; 
						}
					}
				}
			} else {
				// all configured impls must be the same or super type of subcomponent impl
				val subcontCl = subimpltr.containingClassifier
				for (tr : assignedimpls) {
					val trcontCl = tr.containingClassifier
					if (!tr.type.isSuperTypeOf(subimpltr.type) && subcontCl !== trcontCl
					) {
						reportdifferent = true;
					}
				}
			}
			if (reportdifferent) {
				// highlight first extends classifier with CA implementation or cc with CA implementation
				var impls = "(" + firstimpl.type.name + ' in ' + firstcontainingCl.name
				for (tr : assignedimpls) {
					val impl = tr.type as ComponentImplementation
					val trcontainingCl = tr.containingClassifier
					if (tr !== firstimpl) {
						impls += ", " + impl.name+ ' in '+ trcontainingCl.name

					}
				}
				impls += ")"
				error('Subcomponent ' + key + ' has more than one explicitly assigned implementation ' + impls, cc,
					Aadlv3Package.Literals.NAMED_ELEMENT__NAME, MultipleImplementations)
			}
		} else {
			// check against one assigned impl
			val assignedimpl = assignedimpls.get(0).type as ComponentImplementation
			var ClassifierAssignment topca = null
			for (tr : trs) {
				if (tr.type instanceof Classifier) {
					val cl = tr.type as Classifier
					val impl = cl.getTopComponentImplementation
					if (impl !== null) {
						if (!impl.isSuperImplementationOf(assignedimpl)) {
							val ca = tr.containingClassifierAssignment
							if (ca !== null) {
								val caconf = ca.containingClassifier
								val topconf = topca.containingClassifier
								if (caconf !== topconf){
								val idx = if (caconf !== null) {
										cc.superClassifiers.getIndex(caconf)
									} else {
										cc.superClassifiers.getIndex(topconf)
									}

								error(
									'Classifier ' + impl.name + ' assigned to ' + key +
										' is not in extends lineage of ' + assignedimpl.name, cc,
									Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS, idx,
									NoCommonImplementation)
								}
							}
						}
					}
				}
			}
		}
		return
	}

	def checkFeatureDirection(Feature fea) {
		switch (fea.category) {
			case FeatureCategory.BINDING: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES)) {
					error('Binding point direction must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_BINDING_POINT_DIRECTION)
				}
			}
			case BUSACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN || fea.direction == FeatureDirection.REQUIRESIN ||
					fea.direction == FeatureDirection.PROVIDESOUT || fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES
				)) {
					error('Bus access direction must be provides or requires and in or out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_BUS_ACCESS_DIRECTION)
				}
			}
			case DATAACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN || fea.direction == FeatureDirection.REQUIRESIN ||
					fea.direction == FeatureDirection.PROVIDESOUT || fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDESINOUT || fea.direction == FeatureDirection.REQUIRESINOUT
				)) {
					error('Data access direction must be provides or requires and in, out, or in out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_DATA_ACCESS_DIRECTION)
				}
			}
			case FEATURE: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.NONE)) {
					error('Feature direction must be in, out, or no direction', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case INTERFACE: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.NONE)) {
					error('Interface direction must be in, out, or no direction', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case PORT: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.INOUT)) {
					error('Port direction must be in, out, or in out', fea, Aadlv3Package.Literals.FEATURE__DIRECTION,
						BAD_FEATURE_DIRECTION)
				}
			}
			case PARAMETER: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.INOUT)) {
					error('Parameter direction must be in, out, or in out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case SUBPROGRAMACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES	)) {
					error('Subprogram access must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_SUBPROGRAM_ACCESS_DIRECTION)
				}
			}
			case SUBPROGRAMGROUPACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES	)) {
					error('Subprogram group access must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_SUBPROGRAM_GROUP_ACCESS_DIRECTION)
				}
			}
			case VIRTUALBUSACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN || fea.direction == FeatureDirection.REQUIRESIN ||
					fea.direction == FeatureDirection.PROVIDESOUT || fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDESINOUT || fea.direction == FeatureDirection.REQUIRESINOUT
				)) {
					error('Virtual bus access direction must be provides or requires and in or out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_VIRTUAL_BUS_ACCESS_DIRECTION)
				}
			}
		}
	}

	def checkFeatureEvent(Feature fea) {
		if (fea.typeReference?.type?.name === 'event') {
			if (!(fea.category == FeatureCategory.PORT && fea.direction.incomingPort)) {
				error('Event trigger can only be specified for incoming ports', fea,
					Aadlv3Package.Literals.FEATURE__TYPE_REFERENCE, NoEvent)
			}
		}
	}

	def checkConsistentCategory(Classifier cl) {
		val cls = cl.allClassifiers
		val targetcat = cl.componentCategory
		for (matchcl : cls) {
			if (matchcl !== cl) {
				val matchcat = matchcl.componentCategory
				if (matchcat !== targetcat && matchcat !== ComponentCategory.INTERFACE &&
					targetcat !== ComponentCategory.INTERFACE) {
					error('Extension category differs', cl,
						Aadlv3Package.Literals.CLASSIFIER__SUPER_CLASSIFIERS,
						AadlV3Validator.MISMATCHED_COMPONENT_CATEGORY)
				}
			}
		}
	}

	def checkClassifierAssignmentCategory(ClassifierAssignment ca) {
		if(ca.target === null) return;
		if (ca.target.element instanceof Subcomponent) {
			val comp = ca.target.element as Subcomponent
			for (tr : ca.assignedClassifiers) {
				val assignedtype = tr.type
				val thetype = if(assignedtype instanceof ConfigurationParameter) assignedtype.type else assignedtype
				if (thetype instanceof Classifier) {
					val clcat = thetype.componentCategory
					if (!(comp.category === clcat || clcat === ComponentCategory.INTERFACE)) {
						error(
							'Category \'' + clcat + '\' of assigned classifier must be the same as the category \'' +
								comp.category + '\' of the component or must be "abstract"', ca, null,
							MISMATCHED_COMPONENT_CATEGORY)
					}
				} else if (thetype instanceof TypeDef) {
					// primitive type
					if (comp.category === ComponentCategory.DATA || comp.category === ComponentCategory.INTERFACE) {
						if (!comp.typeReferences.empty) {
							error('Assigned primitive type cannot override existing type', ca, null, OverrideType)
						}
					} else {
						error('Configuration assignment expects component classifier', ca, null, NoDataType)
					}
				}
			}
		} else if (ca.target.element instanceof Feature) {
			val fea = ca.target.element as Feature
			if (ca.assignedClassifiers.size > 1) {
				error('Can only assign one type to feature', ca, null, OneType)
			}
			for (tr : ca.assignedClassifiers) {
				val assignedtype = tr.type
				val thetype = if(assignedtype instanceof ConfigurationParameter) assignedtype.type else assignedtype
				if (thetype instanceof Classifier) {
					val clcat = thetype.componentCategory
					if (!(categoriesMatch(clcat, fea.category) ||
						(fea.category === FeatureCategory.INTERFACE && clcat === ComponentCategory.INTERFACE))) {
						error(
							'Category \'' + clcat + '\' of assigned classifier must be the same as the category \'' +
								fea.category + '\' of the feature', ca, null, MISMATCHED_COMPONENT_CATEGORY)
					}
					if (!(fea.category === FeatureCategory.INTERFACE && clcat === ComponentCategory.INTERFACE) &&
						tr.isReverse) {
						error('Only named interfaces can be \'reverse\'', ca,
							Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
							ONLY_INTERFACES_REVERSE)
					}
				} else if (thetype instanceof TypeDef) {
					// data type
					if (fea.category === FeatureCategory.DATAACCESS || fea.category === FeatureCategory.PORT ||
						fea.category === FeatureCategory.FEATURE) {
						if (fea.typeReference !== null) {
							error('Assigned primitive type cannot override existing type', ca, null, OverrideType)
						}
					} else {
						error('Configuration assignment expects component classifier', ca, null, NoDataType)
					}
				}
			}
		} else {
			error('Configuration assignment must be for subcomponent or feature', ca,
				Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__TARGET, FeatureAndSubcomponent)
		}
	}

	/**
	 * Checks that the assigned classifier implementations are in a single extends lineage
	 */
	def void checkSingleImplementationExtendsLineage(ClassifierAssignment ca) {
		var ComponentImplementation top = null
		val trs = ca.assignedClassifiers
		for (tr : trs) {
			if (tr.type instanceof Classifier) {
				val topimpl = (tr.type as Classifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)) {
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)) {
					error('Implementation '+topimpl.name+' is in conflict with implementation ' + top.name, ca,
						Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__ASSIGNED_CLASSIFIERS, trs.indexOf(tr),
						NoCommonImplementation)
				}
			}
		}
	}
	
	/**
	 * Checks that the assigned classifier implementations do not extend the implementation of the subcomponent
	 */
	def void checkExtendsCAImplementation(ClassifierAssignment ca) {
		val trs = ca.assignedClassifiers
		val caimpl = trs.componentImplementation
		if(caimpl === null) return;
		for (tr : trs) {
			if (tr.type instanceof Classifier) {
				val topimpl = (tr.type as Classifier).topComponentImplementation
				if (!topimpl.isSuperImplementationOf(caimpl)) {
					error('Implementation ' + topimpl.name + ' is in conflict with assigned implementation ' +
						caimpl.name, ca, Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
						trs.indexOf(tr), NoCommonImplementation)
				}
			}
		}
	}

	/**
	 * Checks that the assigned classifier implementations do not extend the implementation of the subcomponent
	 */
	def void checkExtendsSubcomponentImplementation(ClassifierAssignment ca) {
		if (ca.target === null) return;
		val sub = ca.target.element
		if (sub instanceof Subcomponent) {
			val subimpl = sub.typeReferences.componentImplementation
			if(subimpl === null) return;
			val trs = ca.assignedClassifiers
			for (tr : trs) {
				if (tr.type instanceof Classifier) {
					val topimpl = (tr.type as Classifier).topComponentImplementation
					if (!topimpl.isSuperImplementationOf(subimpl)) {
						error(
							'Implementation is in conflict with target subcomponent ' + sub.name + ' implementation ' +
								subimpl.name, ca, Aadlv3Package.Literals.CLASSIFIER_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
							trs.indexOf(tr), NoCommonImplementation)
					}
				}
			}
		}
	}

	def checkConsistentDirection(Association assoc) {
		if(assoc.source === null || assoc.destination === null) return
		val srcdir = assoc.source.realFeatureDirection
		val dstdir = assoc.destination.realFeatureDirection
		if (assoc.isConnection) {
			if (!assoc.isBidirectional) {
				if (!(srcdir?.outgoing && dstdir?.incoming)) {
					error('Connection source must be outgoing and destination must be incoming', assoc, null, OUT_TO_IN)
				}
			} else {
				// bidirectional
				if (!(srcdir?.biDirectional && dstdir?.biDirectional)) {
					error('Connection source and destination must be bidirectional', assoc, null, MUST_BE_BI)
				}
			}
		} else if (assoc.isFeatureDelegation) {
			if (!assoc.isBidirectional) {
				if (!(srcdir === dstdir || srcdir === FeatureDirection.NONE || dstdir === FeatureDirection.NONE)) {
					error('Feature delegation directions must be same', assoc, null, SAME_DIRECTION)
				}
				if (srcdir?.biDirectional && dstdir?.biDirectional) {
					// delegate direction must be bidirectional but is directional
					error(
						'Feature delegate declaration must be bidirectional when source and destination are bidirectional',
						assoc, null, MUST_BE_BI)
				}
			} else {
				// bidirectional
				if (!(srcdir?.biDirectional && dstdir?.biDirectional)) {
					error('Feature delegation source and destination must be bidirectional', assoc, null, MUST_BE_BI)
				}
			}
		} else if (assoc.associationType.isFlowSpec) {
			if (srcdir !== null && dstdir !== null && !(srcdir.incoming && dstdir.outgoing)) {
				error('FLow path must be from incoming to outgoing', assoc, null, IN_TO_OUT)

			} else if (srcdir !== null && dstdir === null && !(srcdir.incoming)) {
				error('Flow sink must be incoming', assoc, Aadlv3Package.Literals.ASSOCIATION__SOURCE, MUST_BE_IN)
			} else if (srcdir === null && dstdir !== null && !(dstdir.outgoing)) {
				error('FLow source must be outgoing', assoc, Aadlv3Package.Literals.ASSOCIATION__DESTINATION,
					MUST_BE_OUT)
			}
		} else if (assoc.associationType.isBinding) {
			if (!(srcdir?.outgoingBinding && dstdir?.incomingBinding)) {
				error('Binding must be from requires to provides', assoc, null, REQUIRES_TO_PROVIDES)
			}
		}
	}

	def checkConsistentFeatureCategory(Association assoc) {
		if(assoc.source === null || assoc.destination === null) return
		val srcelem = assoc.source?.element
		val dstelem = assoc.destination?.element
		if (assoc.isConnection || assoc.isFeatureDelegation) {
			if (srcelem instanceof Feature && dstelem instanceof Feature) {
				val src = srcelem as Feature
				val dst = dstelem as Feature
				if (!(src?.category === dst?.category)) {
					error('Feature category of connection/delegate ends must match', assoc, null,
						MATCH_FEATURE_CATEGORY)
				}
			} else if (srcelem instanceof Subcomponent && dstelem instanceof Feature) {
				val srccat = (srcelem as Subcomponent).category
				val dstcat = (dstelem as Feature).category
				if (!categoriesMatch(srccat, dstcat)) {
					error('Feature category of connection/delegate ends must match', assoc, null,
						MATCH_FEATURE_CATEGORY)
				}
			} else if (srcelem instanceof Feature && dstelem instanceof Subcomponent) {
				val srccat = (srcelem as Feature).category
				val dstcat = (dstelem as Subcomponent).category
				if (!categoriesMatch(dstcat, srccat)) {
					error('Feature category of connection/delegate ends must match', assoc, null,
						MATCH_FEATURE_CATEGORY)
				}
			}
		} else if (assoc.associationType.isBinding) {
			if (srcelem instanceof Feature && dstelem instanceof Feature) {
				val src = srcelem as Feature
				val dst = dstelem as Feature
				if (!(src?.isBindingPoint && dst?.isBindingPoint)) {
					error('Binding must be between bindingpoints', assoc, null, MUST_BE_BINDING_POINT)
				}
			}
		} else {
			// others should not have binding points
			if (srcelem instanceof Feature && dstelem instanceof Feature) {
				val src = srcelem as Feature
				val dst = dstelem as Feature
				if (src !== null && src.isBindingPoint || dst !== null && dst.isBindingPoint) {
					error('Bindingpoints can only be in bindings', assoc, null, NO_BINDING_POINT)
				}
			}
		}
	}

	def checkConsistentTargets(Association assoc) {
		if (assoc.isConnection) {
			if(assoc.source === null || assoc.destination === null) return;
			if (!(assoc.source.namedElementReferenceIncludesComponent &&
				assoc.destination.namedElementReferenceIncludesComponent)) {
				error('Connection must be between subcomponents', assoc, null, BetweenSubcomponents)
			}
		}
		if (assoc.isFeatureDelegation) {
			if(assoc.source === null || assoc.destination === null) return;
			val srcdir = assoc.source.realFeatureDirection
			if (srcdir?.outgoing) {
				if (!(assoc.source.namedElementReferenceIncludesComponent &&
					!assoc.destination.namedElementReferenceIncludesComponent)) {
					error('Outgoing feature delegation must be from feature in subcomponent to feature', assoc, null,
						AadlV3Validator.FeatureAndSubcomponent)
				}
			} else {
				if (!(!assoc.source.namedElementReferenceIncludesComponent &&
					assoc.destination.namedElementReferenceIncludesComponent)) {
					error('Feature delegation must be from feature to feature in subcomponent', assoc, null,
						AadlV3Validator.FeatureAndSubcomponent)
				}
			}
		} else if (assoc.associationType.isFlowSpec) {
			if (assoc.source !== null && assoc.destination !== null &&
				(assoc.source.namedElementReferenceIncludesComponent ||
					assoc.destination.namedElementReferenceIncludesComponent)) {
				error('Flow path must not be between features of subcomponents', assoc, null, BetweenFeatures)
			} else // } else if (assoc.associationType === AssociationType.FLOWSINK) {
			if (assoc.source !== null && assoc.destination === null &&
				!(assoc.source.namedElementReferenceIncludesComponent)) {
				error('Flow sink must not be a subcomponent feature', assoc, Aadlv3Package.Literals.ASSOCIATION__SOURCE,
					NotSubcomponentFeature)
			} else // } else if (assoc.associationType === AssociationType.FLOWSOURCE) {
			if (assoc.source === null && assoc.destination !== null &&
				!(assoc.destination.namedElementReferenceIncludesComponent)) {
				error('Flow source must not be a subcomponent feature', assoc,
					Aadlv3Package.Literals.ASSOCIATION__DESTINATION, NotSubcomponentFeature)
			}
		} else if (assoc.associationType.isBinding) {
			if (!(assoc.source.namedElementReferenceIncludesComponent &&
				assoc.destination.namedElementReferenceIncludesComponent)) {
				error('Binding must be between subcomponents', assoc, null, BetweenSubcomponents)
			}
		}
	}

	def checkMatchingTypes(Association assoc) {
		if(assoc.associationType.flowSpec) return;
		if(assoc.source === null || assoc.destination === null) return;
		val srcelem = assoc.source.element
		val dstelem = assoc.destination.element
		if (srcelem instanceof Feature && dstelem instanceof Feature) {
			val src = srcelem as Feature
			val dst = dstelem as Feature
			if (src?.typeReference?.type !== null && dst?.typeReference?.type !== null &&
				src?.typeReference?.type !== dst?.typeReference?.type) {
				error('Association ends must have same type', assoc, null, MatchingTypes)
			}
			if (src?.typeReference?.type !== null && dst?.typeReference?.type === null ||
				src?.typeReference?.type === null && dst?.typeReference?.type !== null) {
				warning('One association end has a type, while the other does not', assoc, null, MissingOneType)
			}
		} else {
			val comptype = if (srcelem instanceof Subcomponent) {
					srcelem.typeReferences.head
				} else if (dstelem instanceof Subcomponent) {
					dstelem.typeReferences.head
				} else {
					null
				}
			val featype = if (srcelem instanceof Feature) {
					srcelem.typeReference
				} else if (dstelem instanceof Feature) {
					dstelem.typeReference
				} else {
					null
				}
			if (comptype === null && featype === null) {
				return;
			}
			if (comptype === null || featype === null) {
				warning('One association end has a type, while the other does not', assoc, null, MissingOneType)
			} else if (comptype.type !== featype.type) {
				error('Association ends must have same type', assoc, null, MatchingTypes)
			}
		}
	}

	def checkPathSequenceConsistency(PathSequence path) {
		var PathElement prevPathElement = null
		for (pathElement : path.elements) {
			val element = pathElement.element
			val prevElement = prevPathElement?.element
			val elementidx = path.elements.indexOf(pathElement)
			if (prevElement instanceof Association) {
				if (prevElement.isFlowSpec) {
					// previous flow spec
					val prevdstcomp = prevPathElement.getClosestReferencedComponent
					if (element instanceof Association) {
						if (element.isFlowSpec) {
							// there must be a connection between them
						} else if (element.isConnection) {
							// connection must start from prev flow spec component
							val currentsrccomp = element.source.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Connection source component differs from destination component of preceding flow spec',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						}
					} else if (element instanceof Subcomponent) {
						// connection destination must be the component
						if (prevdstcomp !== element) {
							error('Component differs from destination component of preceding connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				} else if (prevElement.isConnection) {
					// previous connection
					val prevdstcomp = (prevElement as Association).destination.getClosestReferencedComponent
					if (element instanceof Association) {
						if (element.isFlowSpec) {
							val currentsrccomp = pathElement.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Component of flow spec differs from from destination component of preceding connection',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						} else if (element.isConnection) {
							// both are connection
							// they must connect to the same component
							val currentsrccomp = element.source.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Connection source component differs from destination component of preceding connection',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						}
					} else if (element instanceof Subcomponent) {
						// connection destination must be the component
						if (prevdstcomp !== element) {
							error('Component differs from destination component of preceding connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				}
			} else if (prevElement instanceof Subcomponent) {
				// previous component
				if (element instanceof Association) {
					if (element.isFlowSpec) {
						// there must be a connection
					} else if (element.isConnection) {
						// element is a connection
						// connection source must be same as prev component
						val currentsrccomp = element.source.getClosestReferencedComponent
						if (prevElement !== currentsrccomp) {
							error('Preceding component differs from source component of connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				} else if (element instanceof Subcomponent) {
					// both are component
					// there must be a connection
				}
			}
			prevPathElement = pathElement
		}
	}

}
