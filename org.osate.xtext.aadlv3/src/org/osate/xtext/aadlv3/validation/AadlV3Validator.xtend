/*
 * generated by Xtext 2.14.0
 */
package org.osate.xtext.aadlv3.validation

import com.google.common.collect.SetMultimap
import org.eclipse.xtext.validation.Check
import org.osate.aadlv3.aadlv3.Aadlv3Package
import org.osate.aadlv3.aadlv3.Association
import org.osate.aadlv3.aadlv3.Component
import org.osate.aadlv3.aadlv3.ComponentCategory
import org.osate.aadlv3.aadlv3.ComponentClassifier
import org.osate.aadlv3.aadlv3.ComponentConfiguration
import org.osate.aadlv3.aadlv3.ComponentImplementation
import org.osate.aadlv3.aadlv3.ComponentInterface
import org.osate.aadlv3.aadlv3.ComponentRealization
import org.osate.aadlv3.aadlv3.ConfigurationActual
import org.osate.aadlv3.aadlv3.ConfigurationAssignment
import org.osate.aadlv3.aadlv3.ConfigurationParameter
import org.osate.aadlv3.aadlv3.DataType
import org.osate.aadlv3.aadlv3.Feature
import org.osate.aadlv3.aadlv3.FeatureCategory
import org.osate.aadlv3.aadlv3.FeatureDirection
import org.osate.aadlv3.aadlv3.ModelElement
import org.osate.aadlv3.aadlv3.PathElement
import org.osate.aadlv3.aadlv3.PathSequence
import org.osate.aadlv3.aadlv3.PropertyAssociation
import org.osate.aadlv3.aadlv3.TypeReference

import static org.osate.aadlv3.util.Av3API.*

import static extension org.osate.aadlv3.util.Aadlv3Util.*
import org.osate.aadlv3.aadlv3.PropertyAssociationType
import java.util.Collections
import java.util.Stack
import org.osate.aadlv3.aadlv3.NamedElement
import org.osate.aadlv3.aadlv3.PropertyDefinition
import org.eclipse.emf.ecore.EObject
import org.osate.aadlv3.aadlv3.ModelElementReference
import org.osate.aadlv3.aadlv3.Aadlv3Factory
import org.eclipse.emf.ecore.EStructuralFeature

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AadlV3Validator extends AbstractAadlV3Validator {

	public static val DUPLICATE_NAMES = 'DuplicateNames'
	public static val ONLY_SUPER_INTERFACES = 'OnlySuperInterfaces'
	public static val NO_SUPER_INTERFACES = 'NoSuperInterfaces'
	public static val NO_SUPER_CONFIGURATIONS = 'NoSuperConfigurations'
	public static val BAD_BINDING_POINT_DIRECTION = 'BadBindingPointDirection'
	public static val BAD_BUS_ACCESS_DIRECTION = 'BadBusAccessDirection'
	public static val BAD_VIRTUAL_BUS_ACCESS_DIRECTION = 'BadVirtualBusAccessDirection'
	public static val BAD_SUBPROGRAM_ACCESS_DIRECTION = 'BadSubprogramAccessDirection'
	public static val BAD_SUBPROGRAM_GROUP_ACCESS_DIRECTION = 'BadSubprogramGroupAccessDirection'
	public static val BAD_DATA_ACCESS_DIRECTION = 'BadDataAccessDirection'
	public static val BAD_PORT_DIRECTION = 'BadPortDirection'
	public static val BAD_FEATURE_DIRECTION = 'BadFeatureDirection'
	public static val BAD_INTERFACE_DIRECTION = 'BadInterfaceDirection'
	public static val ONLY_INTERFACES_REVERSE = 'OnlyInterfacesReverse'
	public static val MISMATCHED_COMPONENT_CATEGORY = 'MismatchedCategory'
	public static val IN_TO_OUT = 'InToOut'
	public static val OUT_TO_IN = 'OutToIn'
	public static val SAME_DIRECTION = 'SameDirection'
	public static val REQUIRES_TO_PROVIDES = 'RequiresToProvides'
	public static val MUST_BE_OUT = 'MustBeOut'
	public static val MUST_BE_IN = 'MustBeIn'
	public static val MUST_BE_BI = 'MustBeBidirectional'
	public static val MATCH_FEATURE_CATEGORY = 'MatchFeatureCategory'
	public static val MUST_BE_BINDING_POINT = 'MustBeBindingPoint'
	public static val NO_BINDING_POINT = 'NoBindingPoint'
	public static val BetweenSubcomponents = 'BetweenSubcomponents'
	public static val ToSubcomponents = 'ToSubcomponents'
	public static val FeatureAndSubcomponent = 'FeatureAndSubcomponent'
	public static val NotSubcomponentFeature = 'NotSubcomponentFeature'
	public static val BetweenFeatures = 'BetweenFeatures'
	public static val MatchingTypes = 'MatchingTypes'
	public static val ToFlowSpec = 'ToFlowSpec'
	public static val MissingOneType = 'MissingOneType'
	public static val OnlyPropertyAssociations = 'OnlyPropertyAssociations'
	public static val MustBeDataType = 'MustBeDataType'
	public static val NoDataType = 'NoDataType'
	public static val FormalActualMismatch = 'FormalActualMismatch'
	public static val ConfigurationPattern = 'ConfigurationPattern'
	public static val ParameterNotInterface = 'ParameterNotInterface'
	public static val OverrideType = 'OverrideType'
	public static val OneType = 'OneType'
	public static val DifferentComponentInPath = 'DifferentComponentInPath'
	public static val NoInterface = 'NoComponentInterface'
	public static val DoesNotApply = 'DoesNotApply'
	public static val NoOverride = 'NoOverride'
	public static val NoDoubleAssignment = 'NoDoubleAssignment'
	public static val NoFinalChange = 'NoFinalChange'
	public static val ConflictingFinal = 'ConflictingFinal'
	public static val MustBeFinal = 'MustBeFinal'
	public static val NoCommonImplementation = 'NoCommonImplementation'
	public static val NoEvent = 'NoEvent'

	@Check
	def checkComponentClassifier(ComponentClassifier cl) {
		cl.checkConsistentCategory()
		cl.checkCommonTopComponentImplementation
		cl.checkDuplicatePropertyAssociations
		cl.checkCompositePropertyAssociationFinalConflict
	}

	@Check
	def checkComponentInterface(ComponentInterface cif) {
		cif.checkUniqueModelElementNames()
		cif.checkComponentInterfaceExtensions()
	}

	@Check
	def checkComponentImplementation(ComponentImplementation cimpl) {
		cimpl.checkInterface()
		cimpl.checkUniqueModelElementNames()
		cimpl.checkComponentImplementationExtensions()
		cimpl.checkCompositeConfigurationAssignmentFinalPropertyAssociationConsistency
	}

	@Check
	def checkComponentConfiguration(ComponentConfiguration config) {
		config.checkInterface()
		config.checkConsistentTopImplementation
		config.checkCompositeConfigurationAssignmentFinalPropertyAssociationConsistency
	}

	@Check
	def checkFeature(Feature fea) {
		fea.checkFeatureDirection()
		fea.checkFeatureEvent()
		fea.checkDuplicatePropertyAssociations
		if (fea.category != FeatureCategory.INTERFACE && fea?.typeReference?.isReverse) {
			error('Only interface features can reverse direction', fea, Aadlv3Package.Literals.FEATURE__TYPE_REFERENCE,
				ONLY_INTERFACES_REVERSE)
		}
	}

	@Check
	def checkAssociation(Association assoc) {
		assoc.checkConsistentDirection
		assoc.checkConsistentFeatureCategory
		assoc.checkConsistentTargets
		assoc.checkMatchingTypes
		assoc.checkDuplicatePropertyAssociations
	}

	@Check
	def checkConfigurationAssignment(ConfigurationAssignment ca) {
		ca.checkConfigurationAssignmentCategory
		ca.checkCommonTopComponentImplementation
		ca.checkDuplicatePropertyAssociations
		ca.checkCompositePropertyAssociationFinalConflict
	}

	@Check
	def checkPathSequence(PathSequence flowa) {
		// flow assignment or end to end path
		if (flowa.name === null || flowa.name.empty) {
			// flow assignment
			if (!(flowa.target.element instanceof Association && (flowa.target.element as Association).isFlowSpec)) {
				error('Flow assignment must be for flow specification', flowa,
					Aadlv3Package.Literals.PATH_SEQUENCE__TARGET, ToFlowSpec)
			}
		// the first and last path element may be feature mappings
		}
		// for both the sequence has to be consistent
		flowa.checkPathSequenceConsistency
		flowa.checkDuplicatePropertyAssociations
	}

	@Check
	def checkPathElement(PathElement pe) {
		if (!(pe.element instanceof Association &&
			((pe.element as Association).isFlowSpec || (pe.element as Association).isConnection ||
				(pe.element as Association).isFeatureDelegate) || pe.element instanceof Component)) {
			error('Path element must reference a connection, flow spec, or component', pe, null, ToFlowSpec)
		}
	}

	@Check
	def checkComponent(Component comp) {
		comp.checkConsistentCategory
		comp.checkCommonTopComponentImplementation
		comp.checkDuplicatePropertyAssociations
	}

	@Check
	def checkConfigurationParameter(ConfigurationParameter param) {
		if (!(param.type instanceof ComponentInterface)) {
			error('Configuration parameter type is not a component interface', param,
				Aadlv3Package.Literals.CONFIGURATION_PARAMETER__TYPE, ParameterNotInterface)
		}
	}

	@Check
	def checkConfigurationActual(ConfigurationActual ca) {
		val cif = ca.parameter.type
		if (cif instanceof ComponentClassifier) {
			val assignedtypes = ca.assignedClassifiers
			for (assignedtyperef : assignedtypes) {
				val assignedtype = assignedtyperef.type
				if (assignedtype instanceof ComponentClassifier) {
					if (!(cif.isSuperClassifierOf(assignedtype))) {
						error('Configuration actual does not match component classifier of configuration parameter', ca,
							null, FormalActualMismatch)
					}
				} else if (assignedtype instanceof DataType) {
					error(
						'Configuration actual (data type) does not match component classifier of configuration parameter',
						ca, null, FormalActualMismatch)
				} else if (assignedtype instanceof ConfigurationParameter) {
					val assignedcif = assignedtype.type
					if (assignedcif instanceof ComponentClassifier) {
						if (!(cif.isSuperClassifierOf(assignedcif))) {
							error(
								'Configuration actual is not an extension of component classifier of referenced configuration parameter',
								ca, null, FormalActualMismatch)
						}
					}
				} else {
					// should be an assigned component classifier
					error('Configuration actual is not a component classifier', ca, null, FormalActualMismatch)
				}
			}
		} else if (cif instanceof DataType) {
			val assignedtypes = ca.assignedClassifiers
			for (assignedtyperef : assignedtypes) {
				val assignedtype = assignedtyperef.type
				if (assignedtype instanceof ComponentClassifier) {
					error(
						'Configuration actual (component classifier) does not match configuration parameter data type',
						ca, null, FormalActualMismatch)
				} else if (assignedtype instanceof DataType) {
					if (!(cif.isSuperDataTypeOf(assignedtype))) {
						error(
							'Configuration actual (data type) is not an extension of configuration parameter data type',
							ca, null, FormalActualMismatch)
					}
				} else if (assignedtype instanceof ConfigurationParameter) {
					val assignedcif = assignedtype.type
					if (assignedcif instanceof ComponentClassifier) {
						error(
							'Configuration actual (component classifier) does not match referenced configuration parameter data type',
							ca, null, FormalActualMismatch)
					}
				} else {
					// should be an assigned component classifier
					error('Configuration actual is not a component classifier', ca, null, FormalActualMismatch)
				}
			}
		}
	}

	@Check
	def checkPropertyAssociation(PropertyAssociation pa) {
		pa.checkDuplicatePropertyAssociationForModelElementTarget
		pa.checkPropertyAssociationAppliesto
		pa.checkPropertyAssociationMustBeFinal
		pa.checkLocalComponentPropertyAssociationFinal
		pa.checkLocalSuperClassifierFinal
		pa.checkFinalPropertyAssociationConflictsLocalFinal
	}

	/**
	 * check that it is assigned to a model element that can accept the property
	 */
	def checkPropertyAssociationAppliesto(PropertyAssociation pa) {
		if (pa.target !== null) {
			val targetme = pa.target.element
			switch (targetme) {
				Component: {
					if (!pa.property.appliesToCategory(targetme.category)) {
						val allowedUse = targetme.typeReferences.allowedUseProperties
						if (allowedUse.empty) {
							error('Property does not apply to ' + targetme.category, pa,
								Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
						} else {
							if (!allowedUse.exists[pd|sameProperty(pd, pa.property)]) {
								error('Property does not apply to subcomponent ' + targetme.name, pa,
									Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
							}
						}
					}
				}
				Feature: {
					if (!pa.property.appliesToCategory(targetme.category)) {
						error('Property does not apply to ' + targetme.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Association: {
					if (!pa.property.appliesToCategory(targetme.associationType)) {
						error('Property does not apply to ' + targetme.associationType, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
			}
		} else {
			// associated with containing element
			val paTarget = pa.eContainer
			switch (paTarget) {
				Component: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to ' + paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				ComponentClassifier: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to ' + paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Feature: {
					if (!pa.property.appliesToCategory(paTarget.category)) {
						error('Property does not apply to ' + paTarget.category, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
				Association: {
					if (!pa.property.appliesToCategory(paTarget.associationType)) {
						error('Property does not apply to ' + paTarget.associationType, pa,
							Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, DoesNotApply)
					}
				}
			}
		}
	}

	/**
	 * check the PA is FINAL when in configuration, CA, or reachdown
	 */
	def checkPropertyAssociationMustBeFinal(PropertyAssociation pa) {
		if (pa.eContainer instanceof ConfigurationAssignment) {
			if (pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE) {
				error('Property assignment in configuration assignment must be final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
		} else if (pa.eContainer instanceof ComponentConfiguration) {
			if (pa.propertyAssociationType === PropertyAssociationType.VARIABLE_VALUE) { // && !(pa.eContainer as ComponentConfiguration).superClassifiers.empty){
				error('Property assignment in configuration must be final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
		} else if (pa.target !== null && pa.target.modelElementReferenceReachDown) {
			if (pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE) {
				error('Reach down property assignment must be final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, MustBeFinal)
			}
		}
	}

	def isConfiguredPropertyAssociation(PropertyAssociation pa) {
		return pa.eContainer instanceof ConfigurationAssignment || pa.eContainer instanceof ComponentConfiguration ||
			(pa.target !== null && pa.target.modelElementReferenceReachDown)
	}

	/**
	 * Check whether target model element has a locally assigned FINAL value
	 * Locally assigned is by PA in classifier without target or model element of classifier other than component by {} or MER
	 */
	def checkFinalPropertyAssociationConflictsLocalFinal(PropertyAssociation pa) {
		if(pa.propertyAssociationType !== PropertyAssociationType.FINAL_VALUE) return;
		if (pa.eContainer instanceof ConfigurationAssignment) {
			if (pa.target !== null && pa.target.element.hasLocalFinalPropertyAssociation(pa.property)) {
				error('Locally assigned property value is already final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		} else if (pa.eContainer instanceof ComponentConfiguration) {
			if (pa.target !== null && pa.target.element.hasLocalFinalPropertyAssociation(pa.property)) {
				error('Locally assigned property value is already final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		} else if (pa.target !== null && pa.target.modelElementReferenceReachDown) {
			if (pa.target.element.hasLocalFinalPropertyAssociation(pa.property)) {
				error('Locally assigned property value is already final', pa,
					Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
			}
		}
	}

	def hasLocalFinalPropertyAssociation(ModelElement ne, PropertyDefinition pd) {
		if (ne instanceof Component) {
			// all PA in classifiers listed in component & PA in {} of component
			val pas = ne.typeReferences.allPropertyAssociations + ne.propertyAssociations
			// PA with PD exists and does not have a target, i.e., is for the component and is FINAL
			pas.exists [ pa |
				sameProperty(pa.property, pd) && pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					pa.target === null
			]
		} else {
			// PA in {} & PA in enclosing classifier with ne as target
			val clpas = ne.containingComponentClassifier.allPropertyAssociations
			val mepas = ne.propertyAssociations
			clpas.exists [ pa |
				sameProperty(pa.property, pd) && pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					pa.target === ne
			] || mepas.exists [ pa |
				sameProperty(pa.property, pd) && pa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					pa.target === null
			]
		}
		return false
	}

	/**
	 * check FINAL override by classifiers for Component PAs 
	 */
	def checkLocalComponentPropertyAssociationFinal(PropertyAssociation pa) {
		if (pa.target !== null && pa.target.element instanceof Component) {
			// PA points to component
			val targetme = pa.target.element as Component
			// for all property assignments to components, if the declared component classifier(s) already has a local assignment that is final
			val tpas = targetme.typeReferences.allPropertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && sameProperty(tpa.property, pa.property) &&
					tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error('Property association cannot change final value assigned via classifier ' +
						tpa.containingComponentClassifier.name, pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
				}
			}
		}
		if (pa.target === null && pa.eContainer instanceof Component) {
			// associated with containing element. target is null
			val paTarget = pa.eContainer as Component
			val tpas = paTarget.typeReferences.allPropertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && sameProperty(tpa.property, pa.property) &&
					tpa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error(
						'Property association cannot change final value assigned via classifier ' +
							tpa.containingComponentClassifier.name + ' of enclosing component ' + paTarget.name, pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
				}
			}
		}
	}

	/**
	 * check whether super classifier already assigns final value
	 */
	def checkLocalSuperClassifierFinal(PropertyAssociation pa) {
		// for all model elements the enclosing classifier's super classifiers can have assigned a FINAL value
		if(pa.target?.modelElementReferenceReachDown) return
		// target is null or to a local ME
		val me = pa.target?.element
		val supercls = pa.containingComponentClassifier.allSuperComponentClassifiers
		for (supercl : supercls) {
			val spas = supercl.propertyAssociations
			for (spa : spas) {
				if (spa.target === me && sameProperty(spa.property, pa.property) &&
					spa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error('Property association cannot change final value assigned in ' + supercl.name, pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY_ASSOCIATION_TYPE, NoFinalChange)
				}
			}
		}
	}

	/**
	 * check duplicate PA via {} and local enclosing PA 
	 */
	def checkDuplicatePropertyAssociationForModelElementTarget(PropertyAssociation pa) {
		if (pa.target !== null && !pa.target.modelElementReferenceReachDown) {
			val targetme = pa.target.element
			// local target model element also has {} property assignment 
			val tpas = targetme.propertyAssociations
			for (tpa : tpas) {
				if (tpa.target === null && sameProperty(tpa.property, pa.property)) {
					error('Property value also assigned in {}', pa,
						Aadlv3Package.Literals.PROPERTY_ASSOCIATION__PROPERTY, NoDoubleAssignment)
				}
			}
		}
	}

	/**
	 * check duplicate PA in classifier
	 */
	def checkDuplicatePropertyAssociations(ComponentClassifier cl) {
		checkDuplicatePropertyAssociations(cl.propertyAssociations, cl,
			Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS)
	}

	/**
	 * check duplicate PA in CA
	 */
	def checkDuplicatePropertyAssociations(ConfigurationAssignment ca) {
		checkDuplicatePropertyAssociations(ca.propertyAssociations, ca,
			Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__PROPERTY_ASSOCIATIONS)
	}

	/**
	 * check duplicate PA in Model Element
	 */
	def checkDuplicatePropertyAssociations(ModelElement me) {
		checkDuplicatePropertyAssociations(me.propertyAssociations, me,
			Aadlv3Package.Literals.MODEL_ELEMENT__PROPERTY_ASSOCIATIONS)
	}

	def checkDuplicatePropertyAssociations(Iterable<PropertyAssociation> pas, EObject target,
		EStructuralFeature structuralfeature) {
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (first !== second && sameProperty(first.property, second.property) &&
					first.target?.targetPath == second.target?.targetPath) {
					error('Duplicate property association ' + first.property.name, target, structuralfeature, secondidx,
						NoDoubleAssignment)
					error('Duplicate property association ' + second.property.name, target, structuralfeature, firstidx,
						NoDoubleAssignment)
				}
			}
		}
	}

	/**
	 * conflicting PA in super classifiers of given classifier. 
	 */
	def checkCompositePropertyAssociationFinalConflict(ComponentClassifier cl) {
		val pas = cl.superClassifiers.allPropertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (sameProperty(first.property, second.property) &&
					first.target?.targetPath == second.target?.targetPath &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error(
						'Final property association ' + (second.eContainer as ComponentClassifier).name + '::' +
							second.target.targetPath + '#' + second.property.name + ' conflicts with final ' +
							(first.eContainer as ComponentClassifier).name + '::' + first.target.targetPath + '#' +
							first.property.name, cl, Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS,
						cl.superClassifiers.indexOf(second.eContainer), ConflictingFinal)
				}
			}
		}
	}

	/**
	 * conflicting PA in assigned classifiers of CA
	 */
	def checkCompositePropertyAssociationFinalConflict(ConfigurationAssignment ca) {
		val pas = ca.assignedClassifiers.allPropertyAssociations
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			// check for conflict between PAs from assigned classifiers
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (sameProperty(first.property, second.property) &&
					first.target?.targetPath == second.target?.targetPath &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error(
						'Final property association ' + (second.eContainer as ComponentClassifier).name + '::' +
							second.target.targetPath + '#' + second.property.name + ' conflicts with final ' +
							(first.eContainer as ComponentClassifier).name + '::' + first.target.targetPath + '#' +
							first.property.name, ca,
						Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
						ca.assignedClassifiers.getIndex(second.eContainer), ConflictingFinal)
				}
			}
			// check PA in {} of CA for conflict with PAs from assigned classifiers
			for (curlypa : ca.propertyAssociations) {
				if (sameProperty(first.property, curlypa.property) &&
					first.target?.targetPath == curlypa.target?.targetPath &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					curlypa.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					error(
						'Final property association ' + curlypa.target.targetPath + '#' + curlypa.property.name +
							' conflicts with final ' + (first.eContainer as ComponentClassifier).name + '::' +
							first.target.targetPath + '#' + first.property.name, ca,
						Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__PROPERTY_ASSOCIATIONS,
						ca.propertyAssociations.indexOf(curlypa), ConflictingFinal)
				}
			}
		}
	}

	def int getIndex(Iterable<TypeReference> trs, EObject cl) {
		var cnt = 0
		for (tr : trs) {
			if(tr.type === cl) return cnt
			cnt++
		}
		return -1
	}

	def TypeReference getTypeReference(Iterable<TypeReference> trs, EObject cl) {
		for (tr : trs) {
			if(tr.type === cl) return tr
		}
		return null
	}

	/**
	 * check FINAL PA based on configured components.
	 * casscopes maintains a stack of CAs down the component hierarchy. For each level it is all CAs including those declared nested in other CAs
	 * reachdownPAS maintains a stack of reachdown PAs declared in classifiers configured for the component
	 */
	def void checkCompositeConfigurationAssignmentFinalPropertyAssociationConsistency(ComponentRealization cl) {
		val subs = cl.allSubcomponents
		val casscopes = new Stack<Iterable<ConfigurationAssignment>>()
		val cas = cl.allConfigurationAssignments
		val caspas = cas.map[ca|ca.propertyAssociations].flatten
		checkCompositeCasPasConflict( caspas, cl)
		casscopes.push(cas)
		val reachdownPAS = new Stack<Iterable<PropertyAssociation>>()
		reachdownPAS.push(cl.allPropertyAssociations.filter[pa|pa.target?.modelElementReferenceReachDown])
		for (sub : subs) {
			val rootmer = Aadlv3Factory.eINSTANCE.createModelElementReference
			rootmer.element = sub
			checkNestedPAS(rootmer, casscopes, reachdownPAS, cl)
		}
	}

	def void checkNestedPAS(ModelElementReference context, Stack<Iterable<ConfigurationAssignment>> casscopes,
		Stack<Iterable<PropertyAssociation>> reachdownPAS, ComponentRealization rootcl) {
		val comp = context.element as Component
		var Iterable<TypeReference> trefs = null
		// subcomponent
		trefs = comp.getConfiguredTypeReferences(casscopes)
		if (trefs === null) {
			// inline subcomponents without explicit classifier
			casscopes.push(Collections.EMPTY_LIST)
			reachdownPAS.push(comp.propertyAssociations.filter[pa|pa.target?.modelElementReferenceReachDown])
			comp.components.forEach[subc|context.addComponent(subc).checkNestedPAS(casscopes, reachdownPAS, rootcl)]
			casscopes.pop
			reachdownPAS.pop
		} else {
			val configuredPAS = trefs.allPropertyAssociations.filter[cpa|cpa.isConfiguredPropertyAssociation]
			checkConfiguredCompositePropertyAssociationFinalConflict(configuredPAS, comp, trefs)
			checkReachDownConflict(reachdownPAS, context, configuredPAS, rootcl)
			checkReachDownConfiguredPasConflict(casscopes, context, configuredPAS, rootcl)
			// all CAs including nested ones
			val cas = trefs.allConfigurationAssignments
			val caspas = cas.map[ca|ca.propertyAssociations].flatten
			checkReachDownCasPasConflict(casscopes, context, caspas, rootcl)
			checkCompositeCasPasConflict( caspas, rootcl)
			val comps = trefs.getAllSubcomponents(comp)
			casscopes.push(cas)
			reachdownPAS.push(configuredPAS)
			comps.forEach[subc|context.addComponent(subc).checkNestedPAS(casscopes, reachdownPAS, rootcl)]
			casscopes.pop
			reachdownPAS.pop
		}
	}

	/**
	 * conflict between reachdown and configured PA
	 */
	def void checkReachDownConflict(Stack<Iterable<PropertyAssociation>> reachdownPAS, ModelElementReference context,
		Iterable<PropertyAssociation> configuredPAS, ComponentClassifier rootcl) {
		val n = reachdownPAS.size
		if(n === 0) return;
		for (k : n - 1 .. 0) {
			for (rdPA : reachdownPAS.get(k)) {
				for (configuredPA : configuredPAS) {
					if (matchesReachDown(rdPA.target, configuredPA.target, n - k, context)) {
						// error
						val rdcont = rdPA.eContainer
						if (rdcont instanceof ComponentClassifier) {
							error(
								'Final property association ' + rdPA.target.targetPath + '#' + rdPA.property.name +
									' conflicts with final ' + (configuredPA.eContainer as ComponentClassifier).name + '::' +
									configuredPA.target.targetPath + '#' + configuredPA.property.name + 'configured for component '+context.element.name, rdcont,
								Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS,
								rdcont.propertyAssociations.indexOf(rdPA), ConflictingFinal)
						}
					}
				}
			}
		}
	}
	
	def void checkReachDownConfiguredPasConflict(Stack<Iterable<ConfigurationAssignment>> casscopes,
		ModelElementReference context, Iterable<PropertyAssociation> configuredPAS, ComponentClassifier rootcl) {
		val n = casscopes.size
		if(n === 0) return;
		for (k : n - 1 .. 0) {
			for (ca : casscopes.get(k)) {
				val rdpas = ca.propertyAssociations
				for (rdPA : rdpas) {
					// PAS from configured classifiers
					for (configuredPA : configuredPAS) {
						if (matchesReachDown(rdPA.target, configuredPA.target, n - k, context)) {
							// error
							val rdcont = rdPA.eContainer
							if (rdcont instanceof ComponentClassifier) {
								error(
									'Final property association ' + rdPA.target.targetPath + '#' + rdPA.property.name +
										' conflicts with final ' + (configuredPA.eContainer as ComponentClassifier).name + '::' +
										configuredPA.target.targetPath + '#' + configuredPA.property.name, rdcont,
									Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS,
									rdcont.propertyAssociations.indexOf(rdPA), ConflictingFinal)
							}
						}
					}
				}
			}
		}
	}
	
	def void checkReachDownCasPasConflict(Stack<Iterable<ConfigurationAssignment>> casscopes,
		ModelElementReference context, Iterable<PropertyAssociation> casPAS,ComponentClassifier rootcl) {
		val n = casscopes.size
		if(n === 0) return;
		for (k : n - 1 .. 0) {
			for (ca : casscopes.get(k)) {
				val rdpas = ca.propertyAssociations
				for (rdPA : rdpas) {
					// PAS from configured classifiers
					for (casPA : casPAS) {
						if (matchesReachDown(rdPA.target, casPA.target, n - k, context)) {
							// error
							val rdcont = rdPA.eContainer
							if (rdcont instanceof ComponentClassifier) {
								error(
									'Final property association ' + rdPA.target.targetPath + '#' + rdPA.property.name +
										' conflicts with final ' + (casPA.eContainer as ComponentClassifier).name + '::' +
										casPA.target.targetPath + '#' + casPA.property.name, rdcont,
									Aadlv3Package.Literals.COMPONENT_CLASSIFIER__PROPERTY_ASSOCIATIONS,
									rdcont.propertyAssociations.indexOf(rdPA), ConflictingFinal)
							}
						}
					}
				}
			}
		}
	}
	
	def void checkCompositeCasPasConflict(Iterable<PropertyAssociation> casPAS,
		ComponentRealization rootcl) {
		val n = casPAS.size
		for (var firstidx = 0; firstidx < n - 1; firstidx++) {
			val first = casPAS.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < n; secondidx++) {
				val second = casPAS.get(secondidx)
				if (sameProperty(first.property, second.property) &&
					first.target?.targetPath == second.target?.targetPath &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
						error(
							'Final property association ' +
								second.target.targetPath + '#' + second.property.name + ' conflicts with final ' +
								first.target.targetPath + '#' + first.property.name, 
								rootcl, Aadlv3Package.Literals.COMPONENT_REALIZATION__CONFIGURATION_ASSIGNMENTS,
							rootcl.configurationAssignments.indexOf(second.eContainer), ConflictingFinal)
				}
			}
		}
	}
	

	/**
	 * conflicting PA in configured classifiers of component
	 */
	def checkConfiguredCompositePropertyAssociationFinalConflict(Iterable<PropertyAssociation> pas, Component comp,
		Iterable<TypeReference> trefs) {
		val maxpas = pas.length
		for (var firstidx = 0; firstidx < maxpas - 1; firstidx++) {
			val first = pas.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxpas; secondidx++) {
				val second = pas.get(secondidx)
				if (sameProperty(first.property, second.property) &&
					first.target?.targetPath == second.target?.targetPath &&
					first.propertyAssociationType === PropertyAssociationType.FINAL_VALUE &&
					second.propertyAssociationType === PropertyAssociationType.FINAL_VALUE) {
					val firsttref = trefs.getTypeReference(first.eContainer)
					val secondtref = trefs.getTypeReference(second.eContainer)
					if (firsttref.eContainer === secondtref.eContainer) {
						if (firsttref.eContainer instanceof ConfigurationAssignment) {
							// in same CA
							// already handled
//							val ca = firsttref.eContainer as ConfigurationAssignment
//							error(
//								'coProperty association '+ (second.eContainer as ComponentClassifier).name + '::' + second.target.targetPath + '#' + second.property.name +
//									' conflicts with ' + (first.eContainer as ComponentClassifier).name + '::' +
//									first.target.targetPath + '#' + first.property.name, ca,
//								Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
//								ca.assignedClassifiers.indexOf(secondtref), ConflictingFinal)
						} else if (first.eContainer instanceof ComponentClassifier) {
							// super classifiers
							// already handled
//							val cl = secondtref.eContainer as ComponentClassifier
//							error(
//								'coProperty association ' + (second.eContainer as ComponentClassifier).name + '::' +
//									second.target.targetPath + '#' + second.property.name + ' conflicts with ' +
//									(first.eContainer as ComponentClassifier).name + '::' + first.target.targetPath +
//									'#' + first.property.name, cl,
//								Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS,
//								cl.superClassifiers.indexOf(secondtref), ConflictingFinal)
						}
					} else {
						error(
							'Configured component ' + comp.name + ' property association ' +
								(second.eContainer as ComponentClassifier).name + '::' +
								second.target.targetPath + '#' + second.property.name + ' conflicts with ' +
								(first.eContainer as ComponentClassifier).name + '::' + first.target.targetPath + '#' +
								first.property.name, comp, Aadlv3Package.Literals.COMPONENT__TYPE_REFERENCES,
							trefs.getIndex(second.eContainer), ConflictingFinal)
					}
				}
			}
		}
	}

	def checkUniqueModelElementNames(ComponentInterface cl) {
		val mels = cl.allModelElements.toList
		val max = mels.length
		for (var firstidx = 0; firstidx < max - 1; firstidx++) {
			val first = mels.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < max; secondidx++) {
				val second = mels.get(secondidx)
				if (first !== second && first.name == second.name) {
					reportDuplicateNames(first, cl)
					reportDuplicateNames(second, cl)
				}
			}
		}
	}

	def checkInterface(ComponentRealization cimpl) {
		val interface = getComponentInterface(cimpl);
		if (interface === null) {
			error('Could not find Component Interface', cimpl, null, FormalActualMismatch)
		}
	}

	def checkPattern(ComponentConfiguration config) {
		if (config.superClassifiers.empty) {
			if (!config.configurationAssignments.empty && !config.bindings.empty)
				error('Configurations without extend must only contain configuration assignment patterns', config,
					Aadlv3Package.Literals.COMPONENT_REALIZATION__CONFIGURATION_ASSIGNMENTS, ConfigurationPattern)
		}
	}

	def checkUniqueModelElementNames(ComponentImplementation cl) {
		val mels = cl.allModelElements.toList
		val maxmels = mels.length
		for (var firstidx = 0; firstidx < maxmels - 1; firstidx++) {
			val first = mels.get(firstidx)
			for (var secondidx = firstidx + 1; secondidx < maxmels; secondidx++) {
				val second = mels.get(secondidx)
				if (first !== second && first.name == second.name) {
					// do not report same name of model elements inherited from interface
					if (first.containingComponentClassifier === cl || second.containingComponentClassifier === cl) {
						reportDuplicateNames(first, cl)
						reportDuplicateNames(second, cl)
					}
				}
			}
		}
	}

	def void reportDuplicateNames(ModelElement first, ComponentClassifier cl) {
		val firstcl = first.containingComponentClassifier
		if (firstcl == cl) {
			error('Duplicate model element with name ' + first.name, first, Aadlv3Package.Literals.NAMED_ELEMENT__NAME,
				DUPLICATE_NAMES)
		} else {
			var idx = 0;
			for (sclref : cl.superClassifiers) {
				val scl = sclref.type as ComponentClassifier
				if (firstcl.isSuperClassifierOf(scl)) {
					idx = cl.superClassifiers.indexOf(sclref)
				}
			}
			error('Duplicate model element with name ' + first.name, cl,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, idx, DUPLICATE_NAMES)
		}
	}

	def checkComponentInterfaceExtensions(ComponentInterface cif) {
		if (!cif.superClassifiers.forall[scif|scif.type instanceof ComponentInterface]) {
			error('Interface extensions must be interfaces', cif,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, ONLY_SUPER_INTERFACES)
		}
	}

	def checkComponentImplementationExtensions(ComponentImplementation cim) {
		val allcl = cim.superClassifiers
		if (allcl.exists[scil|scil.type instanceof ComponentInterface]) {
			error('Implementations cannot extend interfaces', cim,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, NO_SUPER_INTERFACES)
		}
		if (allcl.exists[scil|scil.type instanceof ComponentConfiguration]) {
			error('Implementations cannot extend configurations', cim,
				Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, NO_SUPER_CONFIGURATIONS)
		}
	}

	/**
	 * Checks that the top implementations are not parallel super branches
	 */
	def void checkCommonTopComponentImplementation(ComponentClassifier cl) {
		var ComponentImplementation top = null
		val trs = cl.superClassifiers
		for (tr : trs) {
			if (tr.type instanceof ComponentClassifier) {
				val topimpl = (tr.type as ComponentClassifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)) {
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)) {
					error('Implementation is conflict with implementation ' + top.name, cl,
						Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, trs.indexOf(tr),
						NoCommonImplementation)
				}
			}
		}
	}

	/**
	 * Checks that the top implementations are not parallel super branches
	 */
	def void checkCommonTopComponentImplementation(Component sub) {
		var ComponentImplementation top = null
		val trs = sub.typeReferences
		for (tr : trs) {
			if (tr.type instanceof ComponentClassifier) {
				val topimpl = (tr.type as ComponentClassifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)) {
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)) {
					error('Implementation is parallel to top implementation ' + top.name, sub,
						Aadlv3Package.Literals.COMPONENT__TYPE_REFERENCES, trs.indexOf(tr), NoCommonImplementation)
				}
			}
		}
	}

	def void checkConsistentCategory(Component comp) {
		for (tr : comp.typeReferences) {
			val t = tr.type
			if (t instanceof ComponentClassifier) {
				// the categories must be consistent
				val clcat = (tr.type as ComponentClassifier).componentCategory
				if (!(clcat === comp.category || clcat === ComponentCategory.INTERFACE)) {
					error('Component category conflicts with classifier category', comp,
						Aadlv3Package.Literals.COMPONENT__CATEGORY, MISMATCHED_COMPONENT_CATEGORY)
				}
				// data component cannot have classifier, only primitive type
				if (comp.category === ComponentCategory.DATA) {
					error('Data component must have data type', comp, Aadlv3Package.Literals.COMPONENT__CATEGORY,
						MustBeDataType)
				}
			} else if (t instanceof DataType) {
				if (!(comp.category === ComponentCategory.DATA || comp.category === ComponentCategory.INTERFACE)) {
					error('Components other than "data" or "component" cannot have primitive type', comp,
						Aadlv3Package.Literals.COMPONENT__CATEGORY, NoDataType)
				}
			} else {
				// configuration parameter
			}
		}
		// if has type references that are not data type then {} can only contain property associations
		if (!comp.typeReferences.empty && ! comp.typeReferences.isDataType &&
			(!comp.features.empty || !comp.connections.empty || !comp.components.empty)) {
			error('Component with classifier can only have property associations in {}', comp, null,
				OnlyPropertyAssociations)
		}

	}

	def void checkConsistentTopImplementation(ComponentConfiguration cl) {
		val SetMultimap<String, TypeReference> map = cl.cacheClassifierAssignments
		val keys = map.keySet
		for (key : keys) {
			val trs = map.get(key)
			trs.consistentTopComponentImplementation(cl,key)
		}
	}

	/**
	 * returns implementation that is the extension of all other implementations
	 */
	def void consistentTopComponentImplementation(Iterable<TypeReference> trs,ComponentConfiguration cc,String key) {
 		var ComponentImplementation topimpl = null
		var ConfigurationAssignment topca = null
		for (tr : trs) {
			if (tr.type instanceof ComponentClassifier) {
				val cl = tr.type as ComponentClassifier
				val impl = cl.getTopComponentImplementation
				if (impl !== null) {
					if (topimpl === null || topimpl.isSuperImplementationOf(impl)) {
						topimpl = impl
						topca = tr.containingConfigurationAssignment
					} else if (!impl.isSuperImplementationOf(topimpl)) {
						val ca = tr.containingConfigurationAssignment
						if (ca !== null) {
							val caconf = ca.containingComponentClassifier
							val topconf = topca.containingComponentClassifier
							val idx = if (caconf !== null) {
									cc.superClassifiers.getIndex(caconf)
								} else {
									cc.superClassifiers.getIndex(topconf)
								}

							error(
								'Implementation ' + impl.name + ' assigned to ' + key +
									' is not in extends lineage of ' + topimpl.name , cc,
								Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS, idx,
								NoCommonImplementation)
						}
					}
				}
			}
		}
		return
	}

	def checkFeatureDirection(Feature fea) {
		switch (fea.category) {
			case FeatureCategory.BINDINGPOINT: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES)) {
					error('Binding point direction must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_BINDING_POINT_DIRECTION)
				}
			}
			case BUSACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN || fea.direction == FeatureDirection.REQUIRESIN ||
					fea.direction == FeatureDirection.PROVIDESOUT || fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES
				)) {
					error('Bus access direction must be provides or requires and in or out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_BUS_ACCESS_DIRECTION)
				}
			}
			case DATAACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN || fea.direction == FeatureDirection.REQUIRESIN ||
					fea.direction == FeatureDirection.PROVIDESOUT || fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDESINOUT || fea.direction == FeatureDirection.REQUIRESINOUT
				)) {
					error('Data access direction must be provides or requires and in, out, or in out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_DATA_ACCESS_DIRECTION)
				}
			}
			case FEATURE: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.NONE)) {
					error('Feature direction must be in, out, or no direction', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case INTERFACE: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.NONE)) {
					error('Interface direction must be in, out, or no direction', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_FEATURE_DIRECTION)
				}
			}
			case PORT: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.INOUT)) {
					error('Port direction must be in, out, or in out', fea, Aadlv3Package.Literals.FEATURE__DIRECTION,
						BAD_FEATURE_DIRECTION)
				}
			}
			case PARAMETER: {
				if (!(fea.direction == FeatureDirection.IN || fea.direction == FeatureDirection.OUT ||
					fea.direction == FeatureDirection.INOUT)) {
					error('Parameter direction must be in, out, or in out', fea, Aadlv3Package.Literals.FEATURE__DIRECTION,
						BAD_FEATURE_DIRECTION)
				}
			}
			case SUBPROGRAMACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES	)) {
					error('Subprogram access must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_SUBPROGRAM_ACCESS_DIRECTION)
				}
			}
			case SUBPROGRAMGROUPACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDES || fea.direction == FeatureDirection.REQUIRES	)) {
					error('Subprogram group access must be provides or requires', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_SUBPROGRAM_GROUP_ACCESS_DIRECTION)
				}
			}
			case VIRTUALBUSACCESS: {
				if (!(fea.direction == FeatureDirection.PROVIDESIN || fea.direction == FeatureDirection.REQUIRESIN ||
					fea.direction == FeatureDirection.PROVIDESOUT || fea.direction == FeatureDirection.REQUIRESOUT ||
					fea.direction == FeatureDirection.PROVIDESINOUT || fea.direction == FeatureDirection.REQUIRESINOUT
				)) {
					error('Virtual bus access direction must be provides or requires and in or out', fea,
						Aadlv3Package.Literals.FEATURE__DIRECTION, BAD_VIRTUAL_BUS_ACCESS_DIRECTION)
				}
			}
		}
	}
	
	def checkFeatureEvent(Feature fea){
		if (fea.event){
			if (!(fea.category == FeatureCategory.PORT && fea.direction.incomingPort)){
				error('Event trigger can only be specified for incoming ports', fea,
					Aadlv3Package.Literals.FEATURE__EVENT, NoEvent)
			}
		}
	}

	def checkConsistentCategory(ComponentClassifier cl) {
		val cls = cl.allComponentClassifiers
		val targetcat = cl.componentCategory
		for (matchcl : cls) {
			if (matchcl !== cl) {
				val matchcat = matchcl.componentCategory
				if (matchcat !== targetcat && matchcat !== ComponentCategory.INTERFACE &&
					targetcat !== ComponentCategory.INTERFACE) {
					error('Extension category differs', matchcl,
						Aadlv3Package.Literals.COMPONENT_CLASSIFIER__SUPER_CLASSIFIERS,
						AadlV3Validator.MISMATCHED_COMPONENT_CATEGORY)
				}
			}
		}
	}

	def checkConfigurationAssignmentCategory(ConfigurationAssignment ca) {
		if(ca.target === null) return;
		if (ca.target.element instanceof Component) {
			val comp = ca.target.element as Component
			for (tr : ca.assignedClassifiers) {
				val assignedtype = tr.type
				val thetype = if(assignedtype instanceof ConfigurationParameter) assignedtype.type else assignedtype
				if (thetype instanceof ComponentClassifier) {
					val clcat = thetype.componentCategory
					if (!(comp.category === clcat || clcat === ComponentCategory.INTERFACE)) {
						error(
							'Category \'' + clcat + '\' of assigned classifier must be the same as the category \'' +
								comp.category + '\' of the component or must be "abstract"', ca, null,
							MISMATCHED_COMPONENT_CATEGORY)
					}
				} else if (thetype instanceof DataType) {
					// primitive type
					if (comp.category === ComponentCategory.DATA || comp.category === ComponentCategory.INTERFACE) {
						if (!comp.typeReferences.empty) {
							error('Assigned primitive type cannot override existing type', ca, null, OverrideType)
						}
					} else {
						error('Configuration assignment expects component classifier', ca, null, NoDataType)
					}
				}
			}
		} else if (ca.target.element instanceof Feature) {
			val fea = ca.target.element as Feature
			if (ca.assignedClassifiers.size > 1) {
				error('Can only assign one type to feature', ca, null, OneType)
			}
			for (tr : ca.assignedClassifiers) {
				val assignedtype = tr.type
				val thetype = if(assignedtype instanceof ConfigurationParameter) assignedtype.type else assignedtype
				if (thetype instanceof ComponentClassifier) {
					val clcat = thetype.componentCategory
					if (!(categoriesMatch(clcat, fea.category) ||
						(fea.category === FeatureCategory.INTERFACE && clcat === ComponentCategory.INTERFACE))) {
						error(
							'Category \'' + clcat + '\' of assigned classifier must be the same as the category \'' +
								fea.category + '\' of the feature', ca, null, MISMATCHED_COMPONENT_CATEGORY)
					}
					if (!(fea.category === FeatureCategory.INTERFACE && clcat === ComponentCategory.INTERFACE) &&
						tr.isReverse) {
						error('Only named interfaces can be \'reverse\'', ca,
							Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS,
							ONLY_INTERFACES_REVERSE)
					}
				} else if (thetype instanceof DataType) {
					// data type
					if (fea.category === FeatureCategory.DATAACCESS || fea.category === FeatureCategory.PORT ||
						fea.category === FeatureCategory.FEATURE) {
						if (fea.typeReference !== null) {
							error('Assigned primitive type cannot override existing type', ca, null, OverrideType)
						}
					} else {
						error('Configuration assignment expects component classifier', ca, null, NoDataType)
					}
				}
			}
		} else {
			error('Configuration assignment must be for subcomponent or feature', ca,
				Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__TARGET, FeatureAndSubcomponent)
		}
	}

	/**
	 * Checks that the top implementations are not parallel super branches
	 */
	def void checkCommonTopComponentImplementation(ConfigurationAssignment ca) {
		var ComponentImplementation top = null
		val trs = ca.assignedClassifiers
		for (tr : trs) {
			if (tr.type instanceof ComponentClassifier) {
				val topimpl = (tr.type as ComponentClassifier).topComponentImplementation
				if (top === null || top.isSuperImplementationOf(topimpl)) {
					top = topimpl
				} else if (!topimpl.isSuperImplementationOf(top)) {
					error('Implementation is in conflict with implementation ' + top.name, ca,
						Aadlv3Package.Literals.CONFIGURATION_ASSIGNMENT__ASSIGNED_CLASSIFIERS, trs.indexOf(tr),
						NoCommonImplementation)
				}
			}
		}
	}

	def checkConsistentDirection(Association assoc) {
		if(assoc.source === null || assoc.destination === null) return
		val srcdir = assoc.source.realFeatureDirection
		val dstdir = assoc.destination.realFeatureDirection
		if (assoc.associationType.isConnection) {
			if (!assoc.isBidirectional) {
				if (!(srcdir?.outgoing && dstdir?.incoming)) {
					error('Connection source must be outgoing and destination must be incoming', assoc, null, OUT_TO_IN)
				}
			} else {
				// bidirectional
				if (!(srcdir?.biDirectional && dstdir?.biDirectional)) {
					error('Connection source and destination must be bidirectional', assoc, null, MUST_BE_BI)
				}
			}
		} else if (assoc.associationType.isFeatureDelegate) {
			if (!assoc.isBidirectional) {
				if (!(srcdir === dstdir || srcdir === FeatureDirection.NONE || dstdir === FeatureDirection.NONE)) {
					error('Feature delegate directions must be same', assoc, null, SAME_DIRECTION)
				}
				if (srcdir?.biDirectional && dstdir?.biDirectional) {
					// delegate direction must be bidirectional but is directional
					error(
						'Feature delegate declaration must be bidirectional when source and destination are bidirectional',
						assoc, null, MUST_BE_BI)
				}
			} else {
				// bidirectional
				if (!(srcdir?.biDirectional && dstdir?.biDirectional)) {
					error('Feature delegate source and destination must be bidirectional', assoc, null, MUST_BE_BI)
				}
			}
		} else if (assoc.associationType.isFlowSpec) {
			if (srcdir !== null && dstdir !== null && !(srcdir.incoming && dstdir.outgoing)) {
				error('FLow path must be from incoming to outgoing', assoc, null, IN_TO_OUT)

			} else if (srcdir !== null && dstdir === null && !(srcdir.incoming)) {
				error('Flow sink must be incoming', assoc, Aadlv3Package.Literals.ASSOCIATION__SOURCE, MUST_BE_IN)
			} else if (srcdir === null && dstdir !== null && !(dstdir.outgoing)) {
				error('FLow source must be outgoing', assoc, Aadlv3Package.Literals.ASSOCIATION__DESTINATION,
					MUST_BE_OUT)
			}
		} else if (assoc.associationType.isBinding) {
			if (!(srcdir?.outgoingBinding && dstdir?.incomingBinding)) {
				error('Binding must be from requires to provides', assoc, null, REQUIRES_TO_PROVIDES)
			}
		}
	}

	def checkConsistentFeatureCategory(Association assoc) {
		if(assoc.source === null || assoc.destination === null) return
		val srcelem = assoc.source?.element
		val dstelem = assoc.destination?.element
		if (assoc.associationType.isConnection || assoc.associationType.isFeatureDelegate) {
			if (srcelem instanceof Feature && dstelem instanceof Feature) {
				val src = srcelem as Feature
				val dst = dstelem as Feature
				if (!(src?.category === dst?.category)) {
					error('Feature category of connection/delegate ends must match', assoc, null,
						MATCH_FEATURE_CATEGORY)
				}
			} else if (srcelem instanceof Component && dstelem instanceof Feature) {
				val srccat = (srcelem as Component).category
				val dstcat = (dstelem as Feature).category
				if (!categoriesMatch(srccat, dstcat)) {
					error('Feature category of connection/delegate ends must match', assoc, null,
						MATCH_FEATURE_CATEGORY)
				}
			} else if (srcelem instanceof Feature && dstelem instanceof Component) {
				val srccat = (srcelem as Feature).category
				val dstcat = (dstelem as Component).category
				if (!categoriesMatch(dstcat, srccat)) {
					error('Feature category of connection/delegate ends must match', assoc, null,
						MATCH_FEATURE_CATEGORY)
				}
			}
		} else if (assoc.associationType.isBinding) {
			if (srcelem instanceof Feature && dstelem instanceof Feature) {
				val src = srcelem as Feature
				val dst = dstelem as Feature
				if (!(src?.isBindingPoint && dst?.isBindingPoint)) {
					error('Binding must be between bindingpoints', assoc, null, MUST_BE_BINDING_POINT)
				}
			}
		} else {
			// others should not have binding points
			if (srcelem instanceof Feature && dstelem instanceof Feature) {
				val src = srcelem as Feature
				val dst = dstelem as Feature
				if (src !== null && src.isBindingPoint || dst !== null && dst.isBindingPoint) {
					error('Bindingpoints can only be in bindings', assoc, null, NO_BINDING_POINT)
				}
			}
		}
	}

	def checkConsistentTargets(Association assoc) {
		if (assoc.associationType.isConnection) {
			if(assoc.source === null || assoc.destination === null) return;
			if (!(assoc.source.modelElementReferenceIncludesComponent &&
				assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Connection must be between subcomponents', assoc, null, BetweenSubcomponents)
			}
		}
		if (assoc.associationType.isFeatureDelegate) {
			if(assoc.source === null || assoc.destination === null) return;
			val srcdir = assoc.source.realFeatureDirection
			if (srcdir?.outgoing) {
				if (!(assoc.source.modelElementReferenceIncludesComponent &&
					!assoc.destination.modelElementReferenceIncludesComponent)) {
					error('Outgoing feature delegate must be from feature in subcomponent to feature', assoc, null,
						org.osate.xtext.aadlv3.validation.AadlV3Validator.FeatureAndSubcomponent)
				}
			} else {
				if (!(!assoc.source.modelElementReferenceIncludesComponent &&
					assoc.destination.modelElementReferenceIncludesComponent)) {
					error('Feature delegate must be from feature to feature in subcomponent', assoc, null,
						org.osate.xtext.aadlv3.validation.AadlV3Validator.FeatureAndSubcomponent)
				}
			}
		} else if (assoc.associationType.isFlowSpec) {
			if (assoc.source !== null && assoc.destination !== null &&
				!(!assoc.source.modelElementReferenceIncludesComponent &&
					!assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Flow path must not be between features of subcomponents', assoc, null, BetweenFeatures)
			} else // } else if (assoc.associationType === AssociationType.FLOWSINK) {
			if (assoc.source !== null && assoc.destination === null &&
				!(!assoc.source.modelElementReferenceIncludesComponent)) {
				error('Flow sink must not be a subcomponent feature', assoc, Aadlv3Package.Literals.ASSOCIATION__SOURCE,
					NotSubcomponentFeature)
			} else // } else if (assoc.associationType === AssociationType.FLOWSOURCE) {
			if (assoc.source === null && assoc.destination !== null &&
				!(!assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Flow source must not be a subcomponent feature', assoc,
					Aadlv3Package.Literals.ASSOCIATION__DESTINATION, NotSubcomponentFeature)
			}
		} else if (assoc.associationType.isBinding) {
			if (!(!assoc.source.modelElementReferenceIncludesComponent &&
				!assoc.destination.modelElementReferenceIncludesComponent)) {
				error('Binding must be between subcomponents', assoc, null, BetweenSubcomponents)
			}
		}
	}

	def checkMatchingTypes(Association assoc) {
		if(assoc.associationType.flowSpec) return;
		if(assoc.source === null || assoc.destination === null) return;
		val srcelem = assoc.source.element
		val dstelem = assoc.destination.element
		if (srcelem instanceof Feature && dstelem instanceof Feature) {
			val src = srcelem as Feature
			val dst = dstelem as Feature
			if (src?.typeReference?.type !== null && dst?.typeReference?.type !== null &&
				src?.typeReference?.type !== dst?.typeReference?.type) {
				error('Association ends must have same type', assoc, null, MatchingTypes)
			}
			if (src?.typeReference?.type !== null && dst?.typeReference?.type === null ||
				src?.typeReference?.type === null && dst?.typeReference?.type !== null) {
				warning('One association end has a type, while the other does not', assoc, null, MissingOneType)
			}
		} else {
			val comptype = if (srcelem instanceof Component) {
					srcelem.typeReferences.head
				} else if (dstelem instanceof Component) {
					dstelem.typeReferences.head
				} else {
					null
				}
			val featype = if (srcelem instanceof Feature) {
					srcelem.typeReference
				} else if (dstelem instanceof Feature) {
					dstelem.typeReference
				} else {
					null
				}
			if (comptype === null && featype === null) {
				return;
			}
			if (comptype === null || featype === null) {
				warning('One association end has a type, while the other does not', assoc, null, MissingOneType)
			} else if (comptype.type !== featype.type) {
				error('Association ends must have same type', assoc, null, MatchingTypes)
			}
		}
	}

	def checkPathSequenceConsistency(PathSequence path) {
		var PathElement prevPathElement = null
		for (pathElement : path.elements) {
			val element = pathElement.element
			val prevElement = prevPathElement?.element
			val elementidx = path.elements.indexOf(pathElement)
			if (prevElement instanceof Association) {
				if (prevElement.isFlowSpec) {
					// previous flow spec
					val prevdstcomp = prevPathElement.getClosestReferencedComponent
					if (element instanceof Association) {
						if (element.isFlowSpec) {
							// there must be a connection between them
						} else if (element.isConnection) {
							// connection must start from prev flow spec component
							val currentsrccomp = element.source.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Connection source component differs from destination component of preceding flow spec',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						}
					} else if (element instanceof Component) {
						// connection destination must be the component
						if (prevdstcomp !== element) {
							error('Component differs from destination component of preceding connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				} else if (prevElement.isConnection) {
					// previous connection
					val prevdstcomp = (prevElement as Association).destination.getClosestReferencedComponent
					if (element instanceof Association) {
						if (element.isFlowSpec) {
							val currentsrccomp = pathElement.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Component of flow spec differs from from destination component of preceding connection',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						} else if (element.isConnection) {
							// both are connection
							// they must connect to the same component
							val currentsrccomp = element.source.getClosestReferencedComponent
							if (prevdstcomp !== currentsrccomp) {
								error(
									'Connection source component differs from destination component of preceding connection',
									path, Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx,
									DifferentComponentInPath)
							}
						}
					} else if (element instanceof Component) {
						// connection destination must be the component
						if (prevdstcomp !== element) {
							error('Component differs from destination component of preceding connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				}
			} else if (prevElement instanceof Component) {
				// previous component
				if (element instanceof Association) {
					if (element.isFlowSpec) {
						// there must be a connection
					} else if (element.isConnection) {
						// element is a connection
						// connection source must be same as prev component
						val currentsrccomp = element.source.getClosestReferencedComponent
						if (prevElement !== currentsrccomp) {
							error('Preceding component differs from source component of connection', path,
								Aadlv3Package.Literals.PATH_SEQUENCE__ELEMENTS, elementidx, DifferentComponentInPath)
						}
					}
				} else if (element instanceof Component) {
					// both are component
					// there must be a connection
				}
			}
			prevPathElement = pathElement
		}
	}

}
